{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Intel Retail Documentation","text":"<p>Welcome to the Intel Retail organization.</p>"},{"location":"index.html#learn-more-about-our-features","title":"Learn more about our features","text":"<p>Architecture</p> <p>Performance Tools</p> <p>Use Cases</p> <p>Releases</p>"},{"location":"releasenotes.html","title":"Releases","text":"<p>Release v1.0.1</p> <p>Release v1.5.0</p> <p>Release v2.0.0</p> <p>Release v2.1.0</p> <p>Release v3.0.0</p> <p>Release v3.1.0</p> <p>Release v3.2.0</p>"},{"location":"troubleshooting.html","title":"Troubleshooting","text":"<p>Q: Why is the performance on CPU sometimes better than on GPU, when running pipeline benchmarking like stream density?</p> <p>A: The performance of pipeline benchmarking strongly depends on the models.  Specifically for <code>yolov5s</code> object detection, it is recommended to use the model precision FP32 when it is running on device <code>GPU</code>.  If supported, then you can change the model precision by updating the pipeline script to point to the precision of your choice.  For example, you can change the model of <code>FP16</code> to <code>FP32</code> assuming the precision <code>FP32</code> of the target model is available:  </p> <pre><code>    src/pipelines/yolov5s.sh\n\n    ...\n    model=models/object_detection/yolov5s/FP16-INT8/yolov5s.xml\n    ...\n</code></pre> <p>Q: What happens if the system keeps crashing when building the <code>dlstreamer-realsense</code> image?</p> <p>A: Some systems may run into issues with memory when building the <code>dlstreamer-realsense</code> image. In the <code>Dockerfile.dlstreamer</code> file, change the make command to not use the <code>-j</code> threading option.</p> <pre><code>- make -j\"$(cat &lt; /proc/cpuinfo |grep -c proc)\" &amp;&amp;\n+ make &amp;&amp;\n</code></pre> <p>Q: What happens if the RTSP source is not found?</p> <p>A: Depending on your systems performance it is possible that the RTSP simulator may take additional time to initialize and start streaming. To avoid issues you can add a waiting period before the pipeline starts. For example you can add a 5 second sleep timer to /src/entrypoint.sh</p> <pre><code>sleep 5 # sleep for 5 seconds before starting the pipeline\neval $gstLaunchCmd\n</code></pre>"},{"location":"workshops.html","title":"Workshop Collaterals","text":"<p>ASU - 25 Jan 2025</p>"},{"location":"Architecture/pipelines.html","title":"Intel Retail","text":""},{"location":"Architecture/pipelines.html#repositories","title":"Repositories","text":"<p>In release v3.0.0 Intel-retail modules have been organized into logical repositories. By taking advantage of Github submodules different modules can be referenced from other repositories. For example, performance tools are being used by retail-use-cases and automated-self-checkout. Rather than duplicating and maintaining performance tools between the two repositories we linked the latest performance tools release as a submodule. </p> <p></p>"},{"location":"Architecture/pipelines.html#frameworks","title":"Frameworks","text":""},{"location":"Architecture/pipelines.html#openvino","title":"OpenVINO","text":"<p>OpenVINO is an open source toolkit provided by Intel to assist with running AI and ML on Intel hardware. The tools include a portable inference engine that is compatible with different Intel hardware platforms. The code can be found on the OpenVINO Github and examples can be ran with OpenVINO Jupyter Notebooks.</p> <p>OpenVINO provides some pre-trained models for quick development and testing through the OpenVINO Model Zoo. OpenVINO also supports converting models through they Model Conversion Process</p> <p>Details about the latest version can be found in the OpenVINO Release Notes.</p>"},{"location":"Architecture/pipelines.html#dlstreamer-pipeline","title":"DLStreamer Pipeline","text":"<p>Rather than working directly with the OpenVINO APIs our solutions offers more practical ways to interface with OpenVINO. One method is using Intel DLStreamer. This solution provides a no code way based on GStreamer and OpenVINO to deploy, process, and output a pipeline. </p> <p>The diagrams show how we take advantage of Docker, Docker Compose, and environment variable files to pre-package DLStreamer based pipelines for our use cases. Leveraging Environment Variables allows users to modify properties on the fly when different configurations are required.</p> <p></p>"},{"location":"Architecture/pipelines.html#openvino-model-serverovms","title":"OpenVINO Model Server(OVMS)","text":"<p>Another solution is the OpenVINO Model Server(OVMS). OVMS is a model hosting server that hosts inference models through a set of APIs. Unlike DLStreamer this solution requires developers to write code for pre and post processing model inference results. The advantage is the additional control developers have over their inference processing. Another benefit is the distribution of inference workloads between multiple servers either locally or remotely.</p>"},{"location":"Architecture/pipelines.html#openvino-model-serverovms-pipeline-with-grpc-remote-procedure-call","title":"OpenVINO Model Server(OVMS) Pipeline with gRPC (Remote Procedure Call)","text":"<p>There are two methods for running your inference through OVMS. The more flexible method has the client use gRPC (Remote Procedure Call) to request inference results from OVMS. By providing the proper input type and format the client can push inference compute to OVMS. OVMS can be local or on a remote system as long as the requested model is supported. This provides great flexibility with only minor latency increase. </p> <p>The gRPC interface supports c/c++, python, and go. A python example is located in our retail-use-cases gRPC python. The diagram show how the Docker Compose will deploy the client and OVMS. </p> <p></p>"},{"location":"Architecture/pipelines.html#openvino-model-serverovms-pipeline-with-c-api","title":"OpenVINO Model Server(OVMS) Pipeline with C API","text":"<p>When performance is more important than flexibility a developer can use the C API to bypass the gRPC interface and reduce latency. currently this method is only supported for c/c++ and required client/OVMS to both be deployed in a single Docker container. and example of a C API pipeline can be found in retail-use-cases gst_capi. Similar to DLStreamer the Docker Compose only launches a single container per pipeline now that the client/OVMS directly connect through the C API.</p> <p></p>"},{"location":"Architecture/pipelines.html#performance","title":"Performance","text":"<p>More details about benchmarking pipelines can be found on the Performance Tools Page.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html","title":"Distributed Architecture","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/distributed-architecture.html#context","title":"Context","text":"<p>To a wider variety of computer vision use cases in the real world a distributed inference architecture is required for deployment and scale. To achieve this, OpenVINO Model Server (OVMS) will be used for server side inferencing as part of the architecture design. The new architecture will lose some inference throughput but gain flexibility and scale.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#proposed-design","title":"Proposed Design","text":"<p>Using OpenVINO Model Server (OVMS) pipeline, workloads can be distributed between different services. For our solution a single system and remote server setup will be supported.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#single-system-setup","title":"Single System Setup","text":"<p>The single system solution will launch both the OVMS client and OVMS server on the same system as Docker containers. The local network can be used for communication between the Docker containers. The profile launcher program will load the profile configs and environment variables form a local data volume. The computer vision models will also be located on a local data volume. The models can be downloaded using the provided scripts or manually by the user.</p> <p></p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#remote-server-setup","title":"Remote Server Setup","text":"<p>The remote serve set will launch the same OVMS client and OVMS server containers but on two different systems. These systems can be on the same network on in remote locations as long as the systems can communicate through the network. This will require additional security or a direct connection from client to server. Similar to the single system the profile launcher will load the profile configs and environment variables from a data volume. In this case the data volume can be a local copy or a remote copy of those files. On the server the computer vision models will be in a data volume. Unlike the profile config and environment files these must be located on the server in a data volume. This is to prevent any unwanted changes to the computer vision model when it is located in a remote location. </p> <p></p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#running-the-pipeline","title":"Running the Pipeline","text":"<p>The profile launching program will start a pre-configured OVMS client and OVMS server. Run Pipeline documentation covers the parameter details and how to configure different input sources.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#consequences","title":"Consequences","text":"<p>Unlike DLStreamer there will be some latency to call OVMS through gRPC. This will results in a slightly lower stream density for systems. We will however support a wider range and combination of models since the inferencing will be abstracted into the OpenVINO Model Server.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#references","title":"References","text":"<p>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html https://github.com/openvinotoolkit/model_server</p>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html","title":"Multiple OpenVINO Model Server Config JSON","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#context","title":"Context","text":"<p>Currently, we use same config.json for all instances of OpenVINO Model Server(OVMS) pipelines, which leads to some issue regarding the device mounting for OVMS server: see issue intel-retail/automated-self-checkout#322. So we need a way to have multiple or unique config json file per OVMS instance.</p>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#proposed-design","title":"Proposed Design","text":"<p>Move the current device update logic from <code>run.sh</code> with the config.json file into profile-launcher in Golang. When profile-launcher about to launch a new instance of OVMS server, it then produces a unique config json file name for that instance of OVMS server.</p> <p>For example, we can use the Docker container name of that OVMS server like ovms_server0, or ovms_server1,...etc to be appended into the config json as part of the file name (e.g. config_ovms_server0.json).</p> <p>One example golang code for updating json file target_device and producing a new config.json is shown below: <pre><code>// ----------------------------------------------------------------------------------\n// Copyright 2023 Intel Corp.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n//\n// ----------------------------------------------------------------------------------\n\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"reflect\"\n)\n\ntype OvmsConfig struct {\n    ModelList []ModelConfig `json:\"model_config_list\"`\n}\n\ntype ModelConfig struct {\n    Config map[string]interface{} `json:\"config\"`\n}\n\nfunc main() {\n    updateConfig(\"CPU\")\n}\n\nfunc updateConfig(device string) {\n    contents, err := os.ReadFile(\"config_template.json\")\n    if err != nil {\n        err = fmt.Errorf(\"Cannot read json config %v\", err)\n    }\n\n    var data OvmsConfig\n    err = json.Unmarshal(contents, &amp;data)\n    if err != nil {\n        log.Fatalf(\"failed to unmarshal configuration file configuration.yaml: %v\", err)\n    }\n\n    fmt.Println(reflect.TypeOf(data.ModelList))\n\n    for _, model := range data.ModelList {\n        // fmt.Println(model)\n        model.Config[\"target_device\"] = device\n        fmt.Println(model.Config[\"target_device\"])\n        fmt.Println(\"!!!!!!!!!!!!\")\n        fmt.Println(model.Config)\n    }\n\n    // convert to struct\n    updateConfig, err := json.Marshal(data)\n    if err != nil {\n        log.Fatalf(\"could not marshal config to JSON: %v\", err)\n    }\n    _ = os.WriteFile(\"config_ovms_server0.json\", updateConfig, 0644)\n}\n</code></pre></p> <p>This step is done before the profile-launcher calling the <code>start_ovms_server.sh</code>script.</p> <p>In the profile-launcher we also set the correct  environment variable values for the <code>start_ovms_server.sh</code>script to use.  For example, <code>OVMS_MODEL_CONFIG_JSON</code> to be the unique config json file name that was produced from the above example.</p> <p>For clean-up, we can do deletion of the config json files when <code>make clean-all</code> is called or <code>make clean-ovms-server</code> is called.</p>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#references","title":"References","text":"<ul> <li>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html</li> <li>https://github.com/openvinotoolkit/model_server</li> <li>see issue Classification profile crashed when run the 2nd instance switch from CPU to GPU.0 automated-self-checkout#322</li> </ul>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html","title":"Performance Benchmarking","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/performance_benchmarking.html#context","title":"Context","text":"<p>To assist customers we will provide a set of performance Docker containers to measure the performance of their pipelines. The performance Docker containers will need to be supported on most modern Intel hardware. The output will also need to be formatted and presented to customers as a hardware recommendation.</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#proposed-design","title":"Proposed Design","text":""},{"location":"Architecture/v2.0.0/performance_benchmarking.html#benchmark-script","title":"Benchmark Script","text":"<p>The benchmark script is designed to help determine the performance needs for a specific pipeline profile. The script will run a designated pipeline profile and can either replicate that pipeline profile a specific number of times or continue to replicate until a performance target is reached.</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#performance-tools","title":"Performance tools","text":"<p>sysstat: System CPU utilization free: System memory usage iotop: System Disk read and write data igt-gpu-tools: Integrated GPU utilization Intel XPU Manage: Discrete GPU utilization Intel Performance Counter Monitor: System power usage</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#input-source-types","title":"Input Source Types","text":"<p>For performance inputs we support RTSP video streams, USB camera, Intel\u00ae RealSense\u2122 Camera, and video files. For longer benchmarking runs its' recommended to use a video loop with an RTSP stream for inference result consistency. As an option an RTSP Camera Simulator is provided with the performance script.</p> <p>Input Source Types</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#specified-number-of-pipelines","title":"Specified Number of Pipelines","text":"<p>If you are looking to test a specific number of pipelines on different hardware SKUs the <code>--pipelines</code> parameter can be used. This parameter will start the specified number of pipelines </p> <p>Specified Number of Pipelines</p> <p></p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#consolidated-results","title":"Consolidated Results","text":"<p>To make reading results easier, a consolidation script has been provided. This script will work with a single or multiple runs of the specified number of pipelines. Details about this process are found in Benchmark Specified Number of Pipelines</p> <pre><code>make consolidate ROOT_DIRECTORY=&lt;output dir&gt;\n</code></pre>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#stream-density","title":"Stream Density","text":"<p>The stream density parameter can be used to find the maximum number of pipelines at a target frames per second (FPS) on a specific hardware SKU. By setting the <code>--stream_density</code> parameter to the desired FPS the script will continue to create pipelines until the average pipelines FPS falls below the desired FPS. The script will provide a detailed log to show each pipeline FPS during the test run. This option provides a method for testing the top performance when introducing a new pipeline or hardware SKU.</p> <p>Stream Density</p> <p></p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#consequences","title":"Consequences","text":"<p>Having a generic and scalable set of performance Docker containers will allow customers to test a wide range of pipelines and hardware setups without extensive configuration of their systems. The flexibility will bring faster time to market and better hardware decision making by customers.</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#references","title":"References","text":"<p>Pipeline Benchmarking</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html","title":"Distributed Architecture","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/profile-launcher.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/profile-launcher.html#context","title":"Context","text":"<p>Depending on the underlying pipeline architecture you may only require one Docker container or you may require many Docker containers. Specifically OVMS has two methods for running: gRPC which uses remote inference calls from a client to server and Capi which does the inferencing locally. Additionally other methods such as GStreamer are run in a single container. The profiles should be able to accommodate both use cases.</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#proposed-design","title":"Proposed Design","text":"<p>Update the profile to handle an array of configurations. This will allow the user to mix multiple Docker container configurations into a single profile.</p> <p>Each container configuration will contain the following information: - Docker image: The profile launcher will use as the target image - Environment file: Loaded into the container - Entrypoint script: Launch the desired start process - Input arguments: container or entrypoint script - Docker Volumes: Mounted to the container - Docker Networks: Connected to the container</p> <p></p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#single-container-profile","title":"Single Container Profile","text":"<p>A single container profile will run a single Docker image using a single entrypoint script. This use case will be for pipelines that are self contained in a single container. Although the container can interact with other containers on the system the performance tools will only measure the performance of the single running container.</p> <p></p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#multiple-container-profile","title":"Multiple Container Profile","text":"<p>A multiple container profile will run the array of containers defined in the profile config. Each container can have it's own entrypoint script even if they utilize the same base Docker image. The common profile will be the OpenVINO Model Server and client. In this case a OVMS container will contain the inference models defined in the config.json from the profile. Once the OVMS container is started the client will be launched and connect to the OVMS container. This will result in the inference workload being executed in a difference service which can be on the local system or in a remote location. </p> <p></p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#consequences","title":"Consequences","text":"<p>All profiles will need to be updated to use this new array structure. As a benefit common containers such as the OpenVINO Model Server can be shared between profiles.</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#references","title":"References","text":"<p>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html https://github.com/openvinotoolkit/model_server</p>"},{"location":"Architecture/v2.0.0/target-device.html","title":"Distributed Architecture","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/target-device.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/target-device.html#context","title":"Context","text":"<p>The platform parameter is inconsistent with the target device being used in the pipeline. To be consistent with OVMS we want to use the target_device parameter in the script to match the target_device setting in the OVMS config file.</p>"},{"location":"Architecture/v2.0.0/target-device.html#proposed-design","title":"Proposed Design","text":"<p>Update the platform parameter to match the target_device standard used by OpenVINO Model Server. This will provide clarity to the device being used for the inferencing portion of the pipeline. The following are the acceptance criteria for the change.</p> <ul> <li>Replace platform parameter with target_device using CPU as the default device.</li> <li>Update the docker_run script to make it run with minimal changes to the profiles.</li> <li>Confirm that the benchmark script works with the target_device parameter update.</li> <li>Update unit tests</li> <li>Update documentation</li> <li>Convert $DEVICE to $TARGET_DEVICE for internal environment variables.</li> <li>Add option to use existing config file and not override all target_devices to support models with different target_device values.</li> </ul>"},{"location":"Architecture/v2.0.0/target-device.html#target-device-list","title":"Target Device list","text":"Device Parameter Description Links CPU CPU Use CPU only OVMS Parameters GPU GPU Use default GPU OVMS Parameters Specified GPU GPU.x Use a specific GPU. ex. GPU.0 = integrated GPU, GPU.1 = discrete Arc GPU OVMS Parameters Mixed Contifuration MULTI:x,y Use a combination of devices for inferencing ex. MULTI:CPU,GPU.1 will use the CPU and discrete Arc GPU for inferencing OVMS Parameters Automatic Device Selection AUTO Allow OpenVINO to automatically select the optimal device for inferencing Possibly depricated? Automatic Device Selection AUTO Allow OpenVINO to automatically select the optimal device for inferencing Possibly depricated? Heterogeneous Execution HETERO Allows OpenVINO to execute inference on multiple devices Heterogeneous Execution Heterogeneous Execution Priority HETERO:x,y Allows OpenVINO to execute inference on multiple devices and set the priority of device. ex. HETERO:CPU,GPU.1 will prioritize CPU and discrete Arc GPU for inferencing Heterogeneous Execution"},{"location":"Architecture/v2.0.0/target-device.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/target-device.html#consequences","title":"Consequences","text":"<p>Removing the platform parameter will break any existing test and benchmark scripts. The change will clarify which device you are targeting for the inference.</p>"},{"location":"Architecture/v2.0.0/target-device.html#references","title":"References","text":"<p>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html https://github.com/openvinotoolkit/model_server</p>"},{"location":"Architecture/v3.0.0/aicsd-integration.html","title":"Integration of AI Connect for Scientific Devices (AiCSD)","text":"<ul> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>References</li> </ul>"},{"location":"Architecture/v3.0.0/aicsd-integration.html#decision","title":"Decision","text":""},{"location":"Architecture/v3.0.0/aicsd-integration.html#context","title":"Context","text":"<p>This feature would:</p> <ul> <li>provide the ability to integrate pipelines using Intel Geti, BentoML or OpenVino</li> <li>provide the ability to run the entire AiCSD framework including sending images from another machine</li> <li>extend the capability of AiCSD to process still images to include video streams</li> <li>integrate EdgeX</li> </ul>"},{"location":"Architecture/v3.0.0/aicsd-integration.html#proposed-design","title":"Proposed Design","text":""},{"location":"Architecture/v3.0.0/aicsd-integration.html#crawl-integration-of-the-pipeline","title":"Crawl: Integration of the Pipeline","text":"<p>In the initial phases, the solution can be pulled in as just the pieces surrounding the pipeline validation. In order to do this, the Pipeline Validator service can be pulled in. This service  provides the appropriate endpoints and components necessary to call any pipeline built for this system. In the simplest case, the Pipeline Validator service could be used with the  Pipeline Simulator service without the need to add additional models. The Pipeline Simulator will be modified to use go gRPC to call an OVMS inferencing pipeline. In order to send information to the services, it would be necessary to add a script that calls the endpoint to launch the pipeline. When integrating with the benchmarking  script, the AiCSD services will be started using the necessary docker compose files.  This will ensure that all the services are started under the same Docker network. </p> <p></p> <p>Necessary Components:</p> <ul> <li>Pipeline Validator Service</li> <li>EdgeX Services</li> <li>Pipeline from the options below:<ul> <li>Pipeline Simulator (standalone)</li> <li>Intel Geti</li> <li>OVMS</li> <li>BentoML</li> </ul> </li> <li>Script to call launch pipeline for each image in a directory  (or a script that sends the same image for a fixed period of time)</li> <li>Integrate the ability to launch the appropriate target from the profile launcher</li> </ul>"},{"location":"Architecture/v3.0.0/aicsd-integration.html#walk-integrate-the-file-dropping-capability","title":"Walk: Integrate the file dropping capability","text":"<p>Integrate the entire AiCSD solution to add the ability to use two machines - one for generating image and the other for performing the processing. In integration of this feature, it would also be possible to run AiCSD all on one system. The integration will allow  for benchmarking to run alongside this solution.</p> <p>Necessary components:</p> <ul> <li>Desired pipeline</li> <li>AiCSD Gateway Services</li> <li>Integration of launching services with the profile launcher</li> </ul>"},{"location":"Architecture/v3.0.0/aicsd-integration.html#run-add-video-streaming-capability","title":"Run: Add Video Streaming Capability","text":"<p>This feature would allow for the use of video streaming with models supported by  Intel Geti or BentoML. In this solution, it could be necessary to update the AiCSD  solution in order to support the use of video streams. </p>"},{"location":"Architecture/v3.0.0/aicsd-integration.html#references","title":"References","text":"<ul> <li>AiCSD Architecture Overview</li> <li>AiCSD Pipeline Creation</li> </ul>"},{"location":"performance-tools/api-docs.html","title":"API Documentation for Benchmark Scripts","text":""},{"location":"performance-tools/api-docs.html#benchmark-package","title":"Benchmark Package","text":"<ul> <li>Copyright (C) 2025 Intel Corporation. *</li> <li>SPDX-License-Identifier: Apache-2.0</li> </ul>"},{"location":"performance-tools/api-docs.html#benchmark.docker_compose_containers","title":"<code>docker_compose_containers(command, compose_files=[], compose_pre_args='', compose_post_args='', env_vars=os.environ.copy())</code>","text":"<p>helper function to bring up or down containers using the provided params</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <p>valid docker compose command like \"up\" or \"down\"</p> required <code>compose_files</code> <p>list of docker compose files</p> <code>[]</code> <code>compose_pre_args</code> <p>string of arguments called before the command</p> <code>''</code> <code>compose_post_args</code> <p>string of arguments called after the command</p> <code>''</code> <code>env_vars</code> <p>environment variables to use in the shell for calling compose</p> <code>copy()</code> <p>Returns:</p> Name Type Description <code>stdout</code> <p>console output from Popen when running the command</p> <code>stderr</code> <p>console error from Popen when running the command</p> <code>returncode</code> <p>Popen return code</p>"},{"location":"performance-tools/api-docs.html#benchmark.main","title":"<code>main()</code>","text":"<p>runs benchmarking using docker compose for the specified pipeline</p>"},{"location":"performance-tools/api-docs.html#benchmark.parse_args","title":"<code>parse_args(print=False)</code>","text":"<p>parses the input arguments for the command line</p> <p>Parameters:</p> Name Type Description Default <code>print</code> <p>boolean on whether to print the help or not</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>if print is True</p> <code>parser_object</code> <p>if the input arguments are parsed</p>"},{"location":"performance-tools/benchmark.html","title":"Computer Vision Pipeline Benchmarking","text":"<p>The provided Python-based script works with Docker Compose to get pipeline performance metrics like video processing in frames-per-second (FPS), memory usage, power consumption, and so on.</p>"},{"location":"performance-tools/benchmark.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker</li> <li>Docker Compose</li> <li>Make</li> <li>Git</li> <li> <p>Code from Retail Use Cases Repo and its submodule Performance Tools Repo</p> <p>Note</p> <p>To install the submodule, run <code>make update-submodules</code> from the root of the retail-use-cases repo.</p> </li> <li> <p>Python environment v3.12.2</p> <p>Note</p> <p>This could be accomplished using Miniconda and creating a Python 3.12.2 env</p> <pre><code>    sudo apt install git gcc python3-venv python3-dev\n</code></pre> </li> </ul>"},{"location":"performance-tools/benchmark.html#benchmark-a-cv-pipeline","title":"Benchmark a CV Pipeline","text":"<ol> <li> <p>Build the benchmark container and change into the benchmark-scripts directory.</p> <pre><code>    cd performance-tools/\n    make build-benchmark-docker\n</code></pre> </li> <li> <p>Python packages listed in performance-tools/benchmark-scripts/requirements.txt</p> <pre><code>    cd performance-tools/benchmark-scripts/\n    python3 -m venv venv\n    source venv/bin/activate\n    pip install -r requirements.txt\n</code></pre> </li> <li> <p>[Optional] If NPU data collection is desired, ensure that the following is correct.</p> <p>a. Run the following command to get the correct path to the NPU under <code>/sys/devices</code> <pre><code>lspci | grep -i npu\n</code></pre> b. Ensure the environment variable NPU_PATH in performance-tools/docker/docker-compose.yaml for the npu-util service or the global variable in performance-tools/docker/npu-util/npu_logger.py is set to the correct location.    <pre><code>NPU_PATH=\"/sys/devices/pci0000:00/0000:&lt;insert_results&gt;/power/runtime_active_time\"\n</code></pre></p> <p>Example</p> <p>If the lspci command is:</p> <pre><code>$ lspci | grep -i npu\n00:0b.0 Processing accelerators: Intel Corporation Lunar Lake NPU (rev 04)\n</code></pre> <p>then the NPU_PATH is:</p> <pre><code>NPU_PATH=\"/sys/devices/pci0000:00/0000:00:0b.0/power/runtime_active_time\"\n</code></pre> </li> <li> <p>Choose a CV pipeline from the Retail Use Cases Repo, Automated Self-Checkout or Loss Prevention and note the file paths to the docker compose files.</p> </li> <li> <p>Run the benchmarking script using the docker compose file(s) as inputs to the script (sample command shown below).</p> <p>Automated Self-Checkout: <pre><code>    python benchmark.py --compose_file ../../src/docker-compose.yml --pipeline 1\n</code></pre></p> <p>Retail Use Cases: <pre><code>    python benchmark.py --compose_file ../../use-cases/gst_capi/add_camera-simulator.yml --compose_file ../../use-cases/gst_capi/add_gst_capi_yolov5_ensemble.yml\n</code></pre></p> </li> </ol> <p>Go to Arguments to understand how to customize the benchmarks</p> <p>Specific number of pipelines with single container</p> <p></p> <p>Specific number of pipelines with OVMS and Client</p> <p></p>"},{"location":"performance-tools/benchmark.html#benchmark-stream-density-for-cv-pipelines","title":"Benchmark Stream Density for CV Pipelines","text":"<p>Benchmarking a pipeline can also discover the maximum number of workloads or streams that can be run in parallel for a given target FPS. This information is useful to determine the hardware required to achieve the desired performance for CV pipelines.</p> <p>To run the stream density functionality use <code>--target_fps</code> and/or <code>--density_increment</code> as inputs to the <code>benchmark.py</code> script:</p> <pre><code> python benchmark.py  --retail_use_case_root ../../retail-use-cases --target_fps 14.95 --density_increment 1 --init_duration 40   --compose_file ../../retail-use-cases/use-cases/grpc_python/docker-compose_grpc_python.yml\n</code></pre> <p>where the parameters:</p> <ul> <li><code>target_fps</code> is the given target frames per second (fps) to achieve for maximum number of pipelines</li> <li><code>density_increment</code> is to configure the benchmark logic to increase the number of pipelines each time while trying to find out the maximum number of pipelines before reaching the given target fps.</li> <li> <p><code>init_duration</code> is the initial duration period in second before pipeline performance metrics are taken</p> <p>Note</p> <p>It is recommended to set --target_fps to a value lesser than your target FPS to account for real world variances in hardware readings.</p> </li> </ul> <p>Stream density with single container </p> <p>Stream density with OVMS and Client </p>"},{"location":"performance-tools/benchmark.html#consolidate-results","title":"Consolidate results","text":"<p>The consolidate_multiple_run_of_metrics.py script processes and consolidates performance metrics from various log files (JSON, CSV, and text-based logs) into a structured report. It extracts key performance indicators (KPIs) such as CPU &amp; GPU utilization, memory bandwidth, disk I/O, power consumption, and FPS from multiple sources, aggregates the data, and outputs a summary file.</p> <p>on peformance-tools/benchmark-scripts:</p> <pre><code>    make consolidate\n</code></pre> <p>The summary.csv content should look like this:</p> <pre><code>    Camera_20250303214521714278352 FPS,14.86265306122449\n    Camera_20250303214521714278352 Last log update,03/03/2025 14:46:263943\n    CPU Utilization %,10.069166666666668\n    Memory Utilization %,19.70717535119376\n    Disk Read MB/s,0.0\n    Disk Write MB/s,0.002814426229508197\n    S0 Memory Bandwidth Usage MB/s,8012.58064516129\n    S0 Power Draw W,19.159666666666666\n</code></pre>"},{"location":"performance-tools/benchmark.html#modifying-additional-benchmarking-variables","title":"Modifying Additional Benchmarking Variables","text":""},{"location":"performance-tools/benchmark.html#arguments","title":"Arguments","text":"Argument Type Default Value Description <code>--pipelines</code> <code>int</code> <code>1</code> Number of pipelines <code>--target_fps</code> <code>float</code> (list) <code>None</code> Stream density target FPS; can take multiple values for multiple pipelines with 1-to-1 mapping via <code>--container_names</code> <code>--container_names</code> <code>str</code> (list) <code>None</code> Container names for stream density target; used together with <code>--target_fps</code> for 1-to-1 mapping <code>--density_increment</code> <code>int</code> <code>None</code> Pipeline increment number for stream density; dynamically adjusted if not specified <code>--results_dir</code> <code>str</code> <code>'./results'</code> Full path to the directory for logs and results <code>--duration</code> <code>int</code> <code>30</code> Time in seconds, not needed when <code>--target_fps</code> is specified <code>--init_duration</code> <code>int</code> <code>20</code> Initial time in seconds before starting metric data collection <code>--target_device</code> <code>str</code> <code>'CPU'</code> Desired running platform [cpu, core, xeon, dgpu.x] <code>--compose_file</code> <code>str</code> (list) <code>None</code> Path(s) to Docker Compose files; can be used multiple times <code>--retail_use_case_root</code> <code>str</code> <code>'../../'</code> Full path to the retail-use-cases repo root <code>--docker_log</code> <code>str</code> <code>None</code> Docker container name to get logs from and save to a file <code>--parser_script</code> <code>str</code> <code>'./parse_csv_to_json.py'</code> Full path to the parsing script to obtain FPS <code>--parser_args</code> <code>str</code> <code>\"-k device -k igt\"</code> Arguments to pass to the parser script; pass args with spaces in quotes: <code>\"args with spaces\"</code>"},{"location":"performance-tools/benchmark.html#change-power-profile","title":"Change Power Profile","text":"<ul> <li>For Ubuntu, follow this documentation to change the power profile.</li> <li>For Windows, follow this documentation to change the power mode.</li> </ul>"},{"location":"performance-tools/benchmark.html#change-or-customize-metric-parsing","title":"Change or Customize Metric Parsing","text":"<p>Two arguments <code>--parser_script</code> and <code>--parser_args</code> control the script and arguments passed to it respectively from the benchmark script.</p> <ul> <li>The <code>--parser_script</code> can be a python script that takes at least an input argument of <code>-d &lt;results_dir&gt;</code>. This will automatically get passed to the parsing script from the benchmarking script. </li> <li>Any other arguments may be passed using the <code>--parser_args</code>, where arguments with spaces are specified in double quotes.</li> </ul>"},{"location":"performance-tools/benchmark.html#developer-resources","title":"Developer Resources","text":""},{"location":"performance-tools/benchmark.html#python-testing","title":"Python Testing","text":"<p>To run the unit tests for the performance tools:</p> <pre><code>cd benchmark-scripts\nmake python-test\n</code></pre> <p>To run the unit tests and determine the coverage:</p> <pre><code>cd benchmark-scripts\nmake python-coverage\n</code></pre>"},{"location":"release-notes/v1-0-1.html","title":"1.0.1","text":"<p>Intel\u00ae Automated Self-Checkout Reference Package 1.0.0 is the first major release. This release includes all items required to run the vision checkout pipeline and benchmarking. For details on running the solution, refer to the Overview. </p>"},{"location":"release-notes/v1-0-1.html#new-features","title":"New Features","text":"Title Description Pipeline scripts Scripts that run the GStreamer-based vision checkout pipeline Benchmark scripts Scripts that start pipelines and system metrics based on parameters Docker* images Dockerized images for the pipeline and benchmark tools for code portability Set up Documentation Markdown files that include setup steps for initial use Unit tests Basic unit tests scripts for smoke testing Camera simulator Camera simulator script to simulate an RTSP stream using a media file Media downloader script Script to assist with downloading sample media for the camera simulator Model downloader script Script to assist with downloading the model files used for the pipelines"},{"location":"release-notes/v1-0-1.html#issues-fixed","title":"Issues Fixed","text":"Issue Number Description Link None Initial Release"},{"location":"release-notes/v1-0-1.html#known-issues","title":"Known Issues","text":"Issue Number Description Link 15 Pipeline core run on some HW is not producing inference results https://github.com/intel-retail/vision-self-checkout/issues/15 29 Unable to modify batch size from run script https://github.com/intel-retail/vision-self-checkout/issues/29"},{"location":"release-notes/v1-5-0.html","title":"1.5.0","text":"<p>Intel\u00ae Automated Self-Checkout Reference Package 1.5.0 is the second main release. This release includes bug fixes, feature enhancements, dockerization of the benchmarking tools, and OpenVINO Model Server support. For details on running the solution, refer to the Overview. </p>"},{"location":"release-notes/v1-5-0.html#new-features","title":"New Features","text":"Title Description OpenVINO Model Server OpenVINO Model Server support OpenVINO Model Server Pipelines Object detection pipelines using OpenVINO Model Server Benchmark scripts Dockerization Benchmark tools have been moved to Docker containers for more flexible deployment Github Build actions Code linting and security scans for pull requests"},{"location":"release-notes/v1-5-0.html#issues-fixed","title":"Issues Fixed","text":"Issue Number Description 41 Pipeline failure log 42 Create makefile docker commands 51 Optimized density script to reduce run time on high powered systems 55 Make performance / powersave mode configurable 57 Add debug option for docker-run.sh 58 Doc update with makefile 61 rename vision self checkout to automated self checkout 65 Update documentation to include OVMS pipelines 66 Add model download top level script 67 [Tech Debt] Make --workload work in any option/argument position when run benchmark.sh 75 docker-run.sh with wrong message when no --workload option is provided 77 XPU Manager not running on multiple GPUs 85 Fix ShellCheck issues in scripts 88 Incorrect instructions for building IGT in pipelinebenchmarking.md 91 format avc mp4 tag logic is inverted 96 For ovms workload getModels.sh not working when it is called by docker-run.sh from project base directory 99 Clean up some checked in dlstreamer models 100 Add cleaning ovms containers to makefile 105 benchmark pcm directory incorrect 109 igt path pointing to the incorrect directory causing the igt log to not be written 112 make CPU as default device for ovms pipeline 115 add dockerfile.bitModel to download bit models 119 pipelinesetup doc has incorrect link to models.list.yml 124 add ovms sample image download into run script 129 Update License to Apache 2.0 131 update mkdoc to navigate to OVMS doc 142 make build-ovms-server failed for 2nd time or later after removed the Docker image for rebuild"},{"location":"release-notes/v1-5-0.html#known-issues","title":"Known Issues","text":"Issue Number Description Link None"},{"location":"release-notes/v2-0-0.html","title":"2.0.0","text":"<p>Intel\u00ae Automated Self-Checkout Reference Package 2.0.0 is the next major release. This release includes bug fixes, feature enhancements, expansion of the OpenVINO Model Server use cases, implementation of gRPC and C API OVMS pipelines. For details on running the solution, refer to the Overview. </p>"},{"location":"release-notes/v2-0-0.html#new-features","title":"New Features","text":"Title Description OpenVINO Model Server gRPC OpenVINO Model Server support OpenVINO Model Server C API OpenVINO Model Server C API example Github Integration Test Action Nightly integration test action Docker Compose Pipeline Docker Compose version of the pipeline"},{"location":"release-notes/v2-0-0.html#issues-fixed","title":"Issues Fixed","text":"Issue Number Description 2.0 Issues Closed Github issues closed in the 2.0 release"},{"location":"release-notes/v2-0-0.html#known-issues","title":"Known Issues","text":"Issue Number Description Link None"},{"location":"release-notes/v2-1-0.html","title":"2.1.0","text":"<p>Intel\u00ae Automated Self-Checkout Reference Package 2.1.0 is minor maintenance release. This release includes bug fixes, feature enhancements, and a new yolov8 with efficientnet profile using OVMS C API. For details on running the solution, refer to the Overview. </p>"},{"location":"release-notes/v2-1-0.html#new-features","title":"New Features","text":"Title Description Yolov8 + Efficientnet C API Profile OVMS based yolov8 + efficientnet profile Sample video indexing Sample video indexing added for camera simulator container name consistency Batch size param for DLStreamer Add bach size parameter for DLStreamer profiles"},{"location":"release-notes/v2-1-0.html#issues-fixed","title":"Issues Fixed","text":"Issue Number Description 2.1 Issues Closed Github issues closed in the 2.1 release"},{"location":"release-notes/v2-1-0.html#known-issues","title":"Known Issues","text":"Issue Number Description Link None"},{"location":"release-notes/v3-0-0.html","title":"3.0.0","text":"<p>Intel\u00ae Retail organization 3.0.0 is major release. The release splits the Automated Self Checkout reference solution into multiple repositories for improved maintainability and scalability.</p>"},{"location":"release-notes/v3-0-0.html#new-features","title":"New Features","text":"Title Description Documentation (New Repository) Documentation, architecture, and requirements for Intel\u00ae retail repositories Automated Self Checkout Automated self checkout use case Retail Use Cases (New Repository) Retail use cases using DLStreamer and OpenVINO Model Server Performance Tools (New Submodule Repository) Performance tools for pipeline benchmarking"},{"location":"release-notes/v3-0-0.html#issues-fixed","title":"Issues Fixed","text":"<p>Release 3.0.0 Issues Closed</p>"},{"location":"release-notes/v3-0-0.html#known-issues","title":"Known Issues","text":"Issue Number Description Link None"},{"location":"release-notes/v3-1-0.html","title":"3.1.0","text":"<p>Intel\u00ae Retail organization 3.1.0 is major release that adds support for the Edge Video Analytics Microservice (EVAM) pipelines. There is also added support for EVAM visualization tools as well as various bug fixes.</p>"},{"location":"release-notes/v3-1-0.html#new-features","title":"New Features","text":"Title Description Edge Video Analytics Microservice Edge Video Analytics Microservice (EAVM) inference pipelines"},{"location":"release-notes/v3-1-0.html#issues-fixed","title":"Issues Fixed","text":""},{"location":"release-notes/v3-1-0.html#release-310-issues-closed","title":"Release 3.1.0 Issues Closed","text":"Repository Automated Self Checkout Core Services Documentation Performance Tools Retail Use Cases"},{"location":"release-notes/v3-1-0.html#known-issues","title":"Known Issues","text":"Repository Automated Self Checkout Core Services Documentation Performance Tools Retail Use Cases"},{"location":"release-notes/v3-2-0.html","title":"3.2.0","text":"<p>Intel\u00ae Retail organization 3.2.0 is a minor release that add loss prevention use case as well as various bug fixes.</p>"},{"location":"release-notes/v3-2-0.html#new-features","title":"New Features","text":"Title Description Loss Prevention Loss Prevention Use Case"},{"location":"release-notes/v3-2-0.html#issues-fixed","title":"Issues Fixed","text":""},{"location":"release-notes/v3-2-0.html#release-320-issues-closed","title":"Release 3.2.0 Issues Closed","text":"Repository Automated Self Checkout Core Services Documentation Performance Tools Retail Use Cases Loss Prevention"},{"location":"release-notes/v3-2-0.html#known-issues","title":"Known Issues","text":"Repository Automated Self Checkout Core Services Documentation Performance Tools Retail Use Cases Loss Prevention"},{"location":"use-cases/use-cases.html","title":"Intel Retail Use Cases","text":"<ul> <li>Automated Self Checkout</li> <li>AI Connect for Scientific Data (AiCSD)</li> <li>Retail Use Cases: C-API for YOLOV8 ensemble</li> <li>Loss Prevention</li> </ul>"},{"location":"use-cases/AiCSD/aicsd.html","title":"AI Connect for Scientific Data (AiCSD)","text":"<p>This reference implementation is pulled in as a solution for pipeline management and distributed image processing. This solution offers an EdgeX based secure, two-system setup with microservices for managing data transfer and pipeline processing. Visit the solution's GitHub Pages for more information.</p> <p>As an extension to this project, a new service, as-pipeline-grpc-go, allows for  the processing of simulated camera data using a gRPC call to an OVMS server running  yolov5s. For information on how the service works and how to get started, visit the GRPC Yolov5s Pipeline page.</p>"},{"location":"use-cases/AiCSD/pipeline-grpc-go.html","title":"GRPC Yolov5s Pipeline Service","text":""},{"location":"use-cases/AiCSD/pipeline-grpc-go.html#overview","title":"Overview","text":"<p>This EdgeX-based application service provides an interface to use gRPC to call  OVMS to run the input data through a specified model. The service may be set up  to use different topics to trigger different pipelines and call different models. The current implementation makes a call to OVMS running the Yolov5s model.</p>"},{"location":"use-cases/AiCSD/pipeline-grpc-go.html#getting-started","title":"Getting Started","text":"<ol> <li> <p>Clone the Aicsd code as a submodule in the directory retail-use-cases/use-cases     <pre><code>git submodule add https://github.com/intel/AiCSD\n</code></pre></p> </li> <li> <p>Change directories to retail-use-cases     <pre><code>cd ..\n</code></pre></p> </li> <li>Download models and sample media      <pre><code>make download-models download-sample-media\n</code></pre></li> <li> <p>Build the OVMS Docker container     <pre><code>make build-ovms-server\n</code></pre></p> </li> <li> <p>change directories to use-cases/aicsd     <pre><code>cd use-cases/aicsd\n</code></pre></p> </li> <li>Build the Pipeline Validator and Pipeline grpc-go services      <pre><code>make docker-pipeline-val docker-pipeline-grpc-go\n</code></pre></li> <li>Modify docker-compose-pipeline-val.yml evnironment variables to have the following settings     <pre><code>APPLICATIONSETTINGS_PIPELINEHOST: pipeline-grpc-go\nAPPLICATIONSETTINGS_PIPELINEPORT: 59790\n</code></pre></li> <li>Run the pipeline validator and pipeline grpc-go services along with their dependencies     <pre><code>make run-pipeline-grpc-go\n</code></pre></li> <li>Verify that the pipeline-grpc-go container has started by checking the log for the message     <pre><code>level=INFO ts=2024-05-30T20:06:58.037173489Z app=app-pipeline-grpc-go source=messaging.go:125 msg=\"Waiting for messages from the MessageBus on the 'ovms-grpc/yolov5' topic\"\n</code></pre></li> <li>Send a POST request to http://localhost:59788/api/v1/launchPipeline with the following body     <pre><code>{\n    \"InputFileLocation\":\"rtsp://camera-simulator:8554/camera_0\",\n    \"PipelineTopic\":\"ovms-grpc/yolov5\",\n    \"OutputFileFolder\":\"0.0.0.0:8555\"\n}\n</code></pre></li> <li>Verify that the pipeline-grpc-go container has output in its log. This shows that the pipeline is running.     <pre><code>level=INFO ts=2024-05-30T20:06:58.037173489Z app=app-pipeline-grpc-go source=messaging.go:125 msg=\"Waiting for messages from the MessageBus on the 'ovms-grpc/yolov5' topic\"\nlevel=INFO ts=2024-05-30T20:08:37.753137304Z app=app-pipeline-grpc-go source=functions.go:265 msg=\"RunOvmsModel: Processing time: 45 ms; fps: 16.70864819479429\\n\"\nlevel=INFO ts=2024-05-30T20:08:37.685039109Z app=app-pipeline-grpc-go source=functions.go:265 msg=\"RunOvmsModel: Processing time: 37 ms; fps: 16.72014862354332\\n\"\nlevel=INFO ts=2024-05-30T20:08:40.689475521Z app=app-pipeline-grpc-go source=functions.go:265 msg=\"RunOvmsModel: Processing time: 49 ms; fps: 16.368045264717768\\n\"\nlevel=INFO ts=2024-05-30T20:08:40.801842876Z app=app-pipeline-grpc-go source=functions.go:265 msg=\"RunOvmsModel: Processing time: 29 ms; fps: 16.37919507955609\\n\"\n</code></pre></li> <li>To stop the data stream from coming in, stop the camera-simulator and camera-simulator0 containers.</li> <li>Verify that the pipeline-grpc-go container has successfully finished processing by verifying the log says     <pre><code>level=DEBUG ts=2024-05-30T20:10:56.351778319Z app=app-pipeline-grpc-go source=triggermessageprocessor.go:196 msg=\"trigger successfully processed message 'OVMS Pipeline' in pipeline 64a47e72-3e89-452e-9010-2d64c059c108\"\n</code></pre></li> <li>Verify that the job status from the pipeline validator service making a GET request to http://localhost:59788/api/v1/job which should return an entry as follows     <pre><code>[\n    {\n        \"Id\": \"0\",\n        \"Owner\": \"none\",\n        \"InputFile\": {\n            \"Hostname\": \"gateway\",\n            \"DirName\": \"rtsp://camera-simulator:8554/\",\n            \"Name\": \"camera_0\",\n            \"Extension\": \"\",\n            \"ArchiveName\": \"\",\n            \"Viewable\": \"\",\n            \"Attributes\": {}\n        },\n        \"PipelineDetails\": {\n            \"TaskId\": \"de9ee7bd-aacb-4e6a-ac91-a3c3be3b09c3\",\n            \"Status\": \"PipelineComplete\",\n            \"QCFlags\": \"passed\",\n            \"OutputFileHost\": \"\",\n            \"OutputFiles\": null,\n            \"Results\": \"ovms-server0:9001\"\n        },\n        \"LastUpdated\": 1717025357138890553,\n        \"Status\": \"Complete\",\n        \"ErrorDetails\": null,\n        \"Verification\": 0\n    }\n]\n</code></pre></li> <li>Repeat by restarting the camera-simulator services and sending the POST request to <code>launchPipeline</code>.</li> </ol>"},{"location":"use-cases/AiCSD/pipeline-grpc-go.html#tearing-down","title":"Tearing Down","text":"<p>To tear down the services and clean up any data created, run  <pre><code>make down clean-files clean-volumes\n</code></pre></p>"},{"location":"use-cases/automated-self-checkout/advanced.html","title":"Advanced Settings","text":""},{"location":"use-cases/automated-self-checkout/advanced.html#applying-environment-variablesev-to-run-pipeline","title":"Applying Environment Variables(EV) to Run Pipeline","text":"<p>EV can be applied in two ways:</p> <pre><code>1. As a Docker Compose environment parameter input \n2. In the env files\n</code></pre> <p>The input parameter will override the one in the env files if both are used.</p>"},{"location":"use-cases/automated-self-checkout/advanced.html#run-with-custom-environment-variables","title":"Run with Custom Environment Variables","text":"<p>Environment variables with make commands</p> <p>Example</p> <pre><code>make PIPELINE_SCRIPT=yolov5s_effnetb0.sh RESULTS_DIR=\"../render_results\"  run-render-mode\n</code></pre> <p>Environment variable with docker compose up</p> <p>Example</p> <pre><code>PIPELINE_SCRIPT=yolov5s_effnetb0.sh RESULTS_DIR=\"../render_results\" docker compose -f src/docker-compose.yml --env-file src/res/yolov5-cpu.env up -d\n</code></pre> <p>Note</p> <pre><code>The environment variables set like this are known as command line environment overrides and are applied to this run only.\nThey will override the default values in env files and docker-compose.yml.\n</code></pre>"},{"location":"use-cases/automated-self-checkout/advanced.html#editing-the-environment-files","title":"Editing the Environment Files","text":"<p>Environment variable files can be used to persist environment variables between deployments. You can find these files in <code>src/res/</code> folder with our default environment variables for Automated Self Checkout.</p> <pre><code>    - `src/res/all-cpu.env` file for running pipeline on CPU (decoding, pre-processing and inferencing)\n    - `src/res/all-gpu.env` file for running pipeline on GPU (decoding, pre-processing and inferencing)\n    - `src/res/all-dgpu.env` file for running pipeline on discrete GPU (decoding, pre-processing and inferencing)\n    - `src/res/all-npu.env` file for running pipeline on NPU (inferencing)\n    - `src/res/yolov5-cpu-class-gpu.env` file for running pipeline on CPU for detection and GPU for classification\n    - `src/res/yolov5-gpu-class-cpu.env` file for running pipeline on GPU for detection and CPU for classification\n</code></pre> <p>After modifying or creating a new .env file you can load the .env file through the make command or docker compose up</p> <p>Example</p> <pre><code>make PIPELINE_SCRIPT=yolov5s_effnetb0.sh DEVICE_ENV=res/all-gpu.env run-render-mode\ndocker compose -f src/docker-compose.yml --env-file src/res/yolov5-cpu-class-gpu.env up -d\n</code></pre>"},{"location":"use-cases/automated-self-checkout/advanced.html#environment-variables-evs","title":"Environment Variables (EVs)","text":"<p>The table below lists the environment variables (EVs) that can be used as inputs for the container running the inferencing pipeline.</p> Docker Compose EVsDocker Compose ParametersCommon EVs <p>This list of EVs is for running through the make file or docker compose up</p> Variable Description Values <code>DEVICE_ENV</code> Path to device specific environment file that will be loaded into the pipeline container res/all-gpu.env <code>DOCKER_COMPOSE</code> The docker-compose.yml file to run src/docker-compose.yml <code>RETAIL_USE_CASE_ROOT</code> The root directory for Automated Self Checkout in relation to the docker-compose.yml .. <code>RESULTS_DIR</code> Directory to output results ../results <p>This list of parameters that can be set when running docker compose up</p> Variable Description Values <code>-v</code> Volume binding for containers in the Docker Compose -v results/:/tmp/results <code>-e</code> Override environment variables inside of the Docker Container -e LOG_LEVEL debug <p>This list of EVs is common for all profiles.</p> Variable Description Values <code>BARCODE_RECLASSIFY_INTERVAL</code> time interval in seconds for barcode classification Ex: 5 <code>BATCH_SIZE</code> number of frames batched together for a single inference to be used in gvadetect batch-size element 0-N <code>CLASSIFICATION_OPTIONS</code> extra classification pipeline instruction parameters \"\", \"reclassify-interval=1 batch-size=1 nireq=4 gpu-throughput-streams=4\" <code>DETECTION_OPTIONS</code> extra object detection pipeline instruction parameters \"\", \"ie-config=NUM_STREAMS=2 nireq=2\" <code>GST_DEBUG</code> for running pipeline in gst debugging mode 0, 1 <code>LOG_LEVEL</code> log level to be set when running gst pipeline ERROR, INFO, WARNING, and more <code>OCR_RECLASSIFY_INTERVAL</code> time interval in seconds for OCR classification Ex: 5 <code>RENDER_MODE</code> for displaying pipeline and overlay CV metadata 1, 0 <code>PIPELINE_COUNT</code> Number of Automated Self Checkout Docker container instances to launch Ex: 1 <code>PIPELINE_SCRIPT</code> Pipeline script to run. yolov5s.sh, yolov5s_effnetb0.sh, yolov5s_full.sh"},{"location":"use-cases/automated-self-checkout/automated-self-checkout.html","title":"Intel\u00ae Automated Self-Checkout Reference Package","text":""},{"location":"use-cases/automated-self-checkout/automated-self-checkout.html#overview","title":"Overview","text":"<p>As Computer Vision becomes more and more mainstream, especially for industrial &amp; retail use cases, development and deployment of these solutions becomes more challenging. Vision workloads are large and complex and need to go through many stages. For instance, in the pipeline below, the video data is ingested, pre-processed before each inferencing step, inferenced using two models - YOLOv5 and EfficientNet, and post processed to generate metadata and show the bounding boxes for each frame. This pipeline is just an example of the supported models and pipelines found within this reference.</p> <p></p> <p>Automated self-checkout solutions are complex, and retailers, independent software vendors (ISVs), and system integrators (SIs) require a good understanding of hardware and software, the costs involved in setting up and scaling the system, and the configuration that best suits their needs. Vision workloads are significantly larger and require systems to be architected, built, and deployed with several considerations. Hence, a set of ingredients needed to create an automated self-checkout solution is necessary. More details are available on the Intel Developer Focused Webpage and on this LinkedIn Blog</p> <p>The Intel\u00ae Automated Self-Checkout Reference Package provides critical components required to build and deploy a self-checkout use case using Intel\u00ae hardware, software, and other open-source software. This reference implementation provides a pre-configured automated self-checkout pipeline that is optimized for Intel\u00ae hardware. </p>"},{"location":"use-cases/automated-self-checkout/automated-self-checkout.html#next-steps","title":"Next Steps","text":"<p>Note</p> <p>If coming from the catalog please follow the Catalog Getting Started Guide.</p> <p>To begin using the automated self-checkout solution you can follow the Getting Started Guide. </p>"},{"location":"use-cases/automated-self-checkout/automated-self-checkout.html#releases","title":"Releases","text":"<p>For the project release notes, refer to the GitHub* Repository.</p>"},{"location":"use-cases/automated-self-checkout/getting_started.html","title":"Getting Started","text":""},{"location":"use-cases/automated-self-checkout/getting_started.html#step-by-step-instructions","title":"Step by step instructions:","text":"<ol> <li> <p>Download the models using download_models/downloadModels.sh</p> <pre><code>make download-models\n</code></pre> </li> <li> <p>Update github submodules</p> <pre><code>make update-submodules\n</code></pre> </li> <li> <p>Download sample videos used by the performance tools</p> <pre><code>make download-sample-videos\n</code></pre> </li> <li> <p>Build the demo Docker image</p> <pre><code>make build\n</code></pre> </li> <li> <p>Start Automated Self Checkout using the Docker Compose file. The Docker Compose also includes an RTSP camera simulator that will infinitely loop through the sample videos downloaded in step 3.</p> <pre><code>make run-render-mode\n</code></pre> </li> <li> <p>Verify Docker containers</p> <p>Verify Docker images <pre><code>docker ps --format 'table{{.Names}}\\t{{.Status}}\\t{{.Image}}'\n</code></pre> Result: <pre><code>NAMES                 STATUS          IMAGE\ncamera-simulator0     Up 12 seconds   jrottenberg/ffmpeg:4.1-alpine\nsrc-ClientGst-1       Up 14 seconds   dlstreamer:dev\ncamera-simulator      Up 13 seconds   aler9/rtsp-simple-server\n</code></pre></p> </li> <li> <p>Verify Results</p> <p>After starting Automated Self Checkout you will begin to see result files being written into the results/ directory. Here are example outputs from the 3 log files.</p> <p>gst-launch__gst.log <pre><code>libva info: VA-API version 1.22.0\nlibva info: User environment variable requested driver 'iHD'\nlibva info: Trying to open /usr/lib/x86_64-linux-gnu/dri/iHD_drv_video.so\nlibva info: Found init function __vaDriverInit_1_22\nlibva info: va_openDriver() returns 0\nSetting pipeline to PAUSED ...\nPipeline is live and does not need PREROLL ...\nRedistribute latency...\n/GstPipeline:pipeline0/GstFPSDisplaySink:fpsdisplaysink0/GstAutoVideoSink:autovideosink0/GstXvImageSink:autovideosink0-actual-sink-xvimage: sync = true\nProgress: (open) Opening Stream\nPipeline is PREROLLED ...\nPrerolled, waiting for progress to finish...\nProgress: (connect) Connecting to rtsp://localhost:8554/camera_0\n</code></pre> <p>pipeline_gst.log <pre><code>14.58\n14.58\n15.47\n15.47\n15.10\n15.10\n14.60\n14.60\n14.88\n14.88\n</code></pre> <p>r_gst.jsonl <pre><code>{\"resolution\":{\"height\":1080,\"width\":1920},\"timestamp\":1}\n{\"objects\":[{\"detection\":{\"bounding_box\":{\"x_max\":1.0,\"x_min\":0.7868695002029238,\"y_max\":0.8493015899134377,\"y_min\":0.4422388975124676},\"confidence\":0.7139435410499573,\"label\":\"person\",\"label_id\":0},\"h\":440,\"region_id\":486,\"roi_type\":\"person\",\"w\":409,\"x\":1511,\"y\":478}],\"resolution\":{\"height\":1080,\"width\":1920},\"timestamp\":66661013}\n{\"objects\":[{\"detection\":{\"bounding_box\":{\"x_max\":1.0,\"x_min\":0.6974737628926411,\"y_max\":0.8381138710318847,\"y_min\":0.44749696271196093},\"confidence\":0.7188630104064941,\"label\":\"person\",\"label_id\":0},\"h\":422,\"region_id\":576,\"roi_type\":\"person\",\"w\":581,\"x\":1339,\"y\":483}],\"resolution\":{\"height\":1080,\"width\":1920},\"timestamp\":133305076}\n</code></pre> <li> <p>Stop the demo using docker compose down <pre><code>make down\n</code></pre></p> </li>"},{"location":"use-cases/automated-self-checkout/getting_started.html#proceed-to-advanced-settings","title":"Proceed to Advanced Settings","text":""},{"location":"use-cases/automated-self-checkout/getting_started.html#pipeline-performance-tools","title":"Pipeline Performance Tools","text":""},{"location":"use-cases/automated-self-checkout/performance.html","title":"Performance Testing","text":"<p>The performance tools repository is included as a github submodule in this project. The performance tools enable you to test the pipeline system performance on various hardware. </p>"},{"location":"use-cases/automated-self-checkout/performance.html#benchmark-specific-number-of-pipelines","title":"Benchmark specific number of pipelines","text":"<p>Before running benchmark commands, make sure you already configured python and its dependencies. Visit the Performance tools installation guide HERE</p> <p>You can launch a specific number of Automated Self Checkout containers using the PIPELINE_COUNT environment variable. Default is to launch <code>one</code> yolov5s.sh pipeline. You can override these values through Environment Variables.</p> <p>Note</p> <p>The first time running this command may take few minutes. It will build all performance tools containers</p> <p>After running the following commands, you will find the results in <code>performance-tools/benchmark-scripts/results/</code> folder.</p> <pre><code>make benchmark\n</code></pre> <p>Benchmark <code>2</code> pipelines in parallel:</p> <pre><code>make PIPELINE_COUNT=2 benchmark \n</code></pre> <p>Environment variable overrides can also be added to the command:</p> <pre><code>make PIPELINE_SCRIPT=yolov5s_effnetb0.sh DEVICE_ENV=res/all-gpu.env PIPELINE_COUNT=2 benchmark\n</code></pre> <p>Alternatively you can directly call the benchmark.py. This enables you to take advantage of all performance tools parameters. More details about the performance tools can be found HERE</p> <pre><code>cd performance-tools/benchmark-scripts &amp;&amp; python benchmark.py --compose_file ../../src/docker-compose.yml --pipeline 2\n</code></pre>"},{"location":"use-cases/automated-self-checkout/performance.html#benchmark-stream-density","title":"Benchmark Stream Density","text":"<p>To test the maximum amount of Automated Self Checkout containers/pipelines that can run on a given system you can use the TARGET_FPS environment variable. Default is to find the container threshold over FPS over 14.95 with the yolov5s.sh pipeline. You can override these values through Environment Variables.</p> <pre><code>make benchmark-stream-density\n</code></pre> <p>You can check the output results for performance metrics in the <code>results</code> folder at the root level. Also, the stream density script will output the results in the console:</p> <pre><code>Total averaged FPS per stream: 15.210442307692306 for 26 pipeline(s)\n</code></pre> <p>Change the Target FPS value:</p> <pre><code>make TARGET_FPS=13.5 benchmark-stream-density\n</code></pre> <p>Environment variable overrides can also be added to the command</p> <pre><code>make PIPELINE_SCRIPT=yolov5s_effnetb0.sh TARGET_FPS=13.5 benchmark-stream-density\n</code></pre> <p>Alternatively you can directly call the benchmark.py. This enables you to take advantage of all performance tools parameters. More details about the performance tools can be found HERE</p> <pre><code>cd performance-tools/benchmark-scripts &amp;&amp; python benchmark.py --compose_file ../../src/docker-compose.yml --target_fps 14\n</code></pre>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html","title":"Getting Started Guide","text":"<ul> <li>Time to Complete: 30 minutes</li> <li>Programming Language: Python3, Bash</li> </ul>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#prerequisites-for-target-system","title":"Prerequisites for Target System","text":"<ul> <li>Intel\u00ae Core\u2122 processor</li> <li>At least 16 GB RAM</li> <li>At least 64 GB hard drive</li> <li>An Internet connection</li> <li>Docker*</li> <li>Docker Compose* v2 (Optional)</li> <li>Git*</li> <li>Ubuntu* LTS Boot Device</li> </ul> <p>If Ubuntu is not installed on the target system, follow the instructions and install Ubuntu.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#install-automated-self-checkout-package-software","title":"Install Automated Self-Checkout Package Software","text":"<p>Do the following to install the software package:</p> <ol> <li> <p>Download the reference implementation package:       Automated Self-Checkout Retail Reference Implementation.</p> </li> <li> <p>Open a new terminal and navigate to the download folder to unzip the <code>automated-self-checkout</code> package:</p> <pre><code>   unzip automated-self-checkout.zip\n</code></pre> </li> <li> <p>Navigate to the <code>automated-self-checkout/</code> directory:</p> <pre><code> cd automated-self-checkout\n</code></pre> </li> <li> <p>Change permission of the executable edgesoftware file:</p> <pre><code>   chmod 755 edgesoftware\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>   ./edgesoftware install\n</code></pre> </li> <li> <p>You will be prompted for the Product Key during the installation. The Product Key is in the email you received from Intel confirming your download.</p> <p>When the installation is complete, you will see the message\u202f\u201cInstallation of package complete\u201d and the installation status for each module.</p> <p></p> </li> </ol> <p>If the installation fails because of proxy-related issues, follow the troubleshooting steps.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#run-and-evaluate-pre-configured-pipelines","title":"Run and Evaluate Pre-Configured Pipelines","text":"<p>In a retail environment, self-checkout solutions analyze video streams from multiple cameras to streamline the checkout process. The system detects and classifies products as items are scanned. Barcode and text recognition ensure accuracy. This data is processed to verify purchases and update inventory in real time. Factors such as latency and frames per second (FPS) help assess the automated self-checkout solution's real-time responsiveness and efficiency.</p> <p>This demonstration shows how to run the pre-configured pipeline, view a simulation that detects and tracks objects, and check the pipeline's status.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#step-1-run-pipeline","title":"Step 1: Run Pipeline","text":"<p>Do the following to run the pre-configured pipeline:</p> <ol> <li> <p>Navigate to the <code>automated-self-checkout</code> directory:</p> <pre><code>   cd automated-self-checkout\n</code></pre> </li> <li> <p>Modify the following host IP addresses to match the IP address of the system running the reference implementation: </p> <ul> <li><code>HOST_IP</code> and <code>RSTP_CAMERA_IP</code> in the <code>src/pipeline-server/.env</code> file. </li> <li><code>host_ip</code> in the <code>src/pipeline-server/postman/env.json</code> file.</li> </ul> </li> <li> <p>Run the pipeline server:</p> <pre><code>   make run-pipeline-server\n</code></pre> <p>The containers will start to run.</p> <p></p> </li> </ol>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#step-2-launch-grafana-dashboard","title":"Step 2: Launch Grafana Dashboard","text":"<p>Do the following to launch the Grafana* dashboard to view the objects being detected and tracked:</p> <ol> <li> <p>Open a web browser and enter the following URL to access the Grafana dashboard:       <code>http://&lt;target_system_IP&gt;:3000</code>.</p> <p>To get <code>&lt;target_system_IP&gt;</code>, run the <code>hostname -I</code> command.</p> </li> <li> <p>When prompted, provide the following credentials:</p> <ul> <li>Username: <code>root</code></li> <li>Password: <code>evam123</code></li> </ul> </li> <li> <p>On the dashboard, go to Menu &gt; Home, and select Video Analytics Dashboard.</p> <p>The dashboard visualizes the object detection and tracking pipelines. The bounding boxes around the products indicate their detection and tracking. The dashboard also shows the active streams and their corresponding average FPS.</p> <p></p> </li> </ol>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#step-3-check-pipeline-status","title":"Step 3: Check Pipeline Status","text":"<p>Do the following to check the metrics: </p> <ol> <li> <p>Check whether the docker containers are running:</p> <p><pre><code>   docker ps --format 'table{{.Names}}\\t{{.Image}}\\t{{.Status}}'\n</code></pre> </p> </li> <li> <p>Check the MQTT inference output:</p> <pre><code>   mosquitto_sub -v -h localhost -p 1883 -t 'AnalyticsData0'\n   mosquitto_sub -v -h localhost -p 1883 -t 'AnalyticsData1'\n   mosquitto_sub -v -h localhost -p 1883 -t 'AnalyticsData2'\n</code></pre> <p>Here is the result for <code>AnalyticsData0</code>:</p> <pre><code>   AnalyticsData0 {\"objects\":[{\"detection\":{\"bounding_box\":{\"x_max\":0.3163176067521043,\"x_min\":0.20249048400491532,\"y_max\":0.7995593662281202,\"y_min\":0.12237883070032396},\"confidence\":0.868196964263916,\"label\":\"bottle\",\"label_id\":39},\"h\":731,\"region_id\":6199,\"roi_type\":\"bottle\",\"w\":219,\"x\":389,\"y\":132},{\"detection\":{\"bounding_box\":{\"x_max\":0.7833052431819754,\"x_min\":0.6710088227893136,\"y_max\":0.810283140877349,\"y_min\":0.1329853767638305},\"confidence\":0.8499506711959839,\"label\":\"bottle\",\"label_id\":39},\"h\":731,\"region_id\":6200,\"roi_type\":\"bottle\",\"w\":216,\"x\":1288,\"y\":144}],\"resolution\":{\"height\":1080,\"width\":1920},\"tags\":{},\"timestamp\":67297301635}\n\n   AnalyticsData0 {\"objects\":[{\"detection\":{\"bounding_box\":{\"x_max\":0.3163306922646063,\"x_min\":0.20249845268772138,\"y_max\":0.7984013488063937,\"y_min\":0.12254781445953},\"confidence\":0.8666459321975708,\"label\":\"bottle\",\"label_id\":39},\"h\":730,\"region_id\":6201,\"roi_type\":\"bottle\",\"w\":219,\"x\":389,\"y\":132},{\"detection\":{\"bounding_box\":{\"x_max\":0.7850104587729607,\"x_min\":0.6687324296210857,\"y_max\":0.7971464600783804,\"y_min\":0.13681757042794374},\"confidence\":0.8462932109832764,\"label\":\"bottle\",\"label_id\":39},\"h\":713,\"region_id\":6202,\"roi_type\":\"bottle\",\"w\":223,\"x\":1284,\"y\":148}],\"resolution\":{\"height\":1080,\"width\":1920},\"tags\":{},\"timestamp\":67330637174}\n</code></pre> </li> <li> <p>Check the pipeline status:</p> <p><pre><code>   ./src/pipeline-server/status.sh \n</code></pre>   The pipeline status should be like:</p> <pre><code>   --------------------- Pipeline Status ---------------------\n   ----------------8080----------------\n   [\n   {\n         \"avg_fps\": 11.862402507697258,\n         \"avg_pipeline_latency\": 0.5888091060475129,\n         \"elapsed_time\": 268.07383918762207,\n         \"id\": \"95204aba458211efa9080242ac180006\",\n         \"message\": \"\",\n         \"start_time\": 1721361269.6349292,\n         \"state\": \"RUNNING\"\n   }\n   ]\n</code></pre> <p>The pipeline status displays the average FPS and average pipeline latency, among other metrics. </p> </li> <li> <p>Stop the services:</p> <pre><code>   make down-pipeline-server\n</code></pre> </li> </ol>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#summary","title":"Summary","text":"<p>In this get started guide, you learned how to:</p> <ul> <li>Install the automated self-checkout package software.</li> <li>Verify the installation.</li> <li>Run pre-configured pipelines, visualize object detection and tracking, and extract data from them.</li> </ul>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#learn-more","title":"Learn More","text":"<ul> <li>To apply custom environment variables, see Advanced Settings.</li> <li>To evaluate the pipeline system performance across different hardware, see Test Performance.</li> </ul>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#troubleshooting","title":"Troubleshooting","text":"<p>Issues with Docker Installation</p> <p>If you are behind a proxy and if you experience connectivity issues, the Docker installation might fail. Do the following to install Docker manually:</p> <ol> <li>Install Docker from a package.</li> <li>Complete the post-installation steps to manage Docker as a non-root user.</li> <li>Configure the Docker CLI to use proxies.</li> </ol>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#error-logs","title":"Error Logs","text":"<p>To access the Docker Logs for EVAM server 0, run the following command: </p> <p><pre><code>   docker logs evam_0\n</code></pre>    Here is an example of the error log when the RSTP stream is unreachable for a pipeline:</p> <pre><code>   {\"levelname\": \"INFO\", \"asctime\": \"2024-07-31 23:26:47,257\", \"message\": \"===========================\", \"module\": \"pipeline_manager\"}\n   {\"levelname\": \"INFO\", \"asctime\": \"2024-07-31 23:26:47,257\", \"message\": \"Completed Loading Pipelines\", \"module\": \"pipeline_manager\"}\n   {\"levelname\": \"INFO\", \"asctime\": \"2024-07-31 23:26:47,257\", \"message\": \"===========================\", \"module\": \"pipeline_manager\"}\n   {\"levelname\": \"INFO\", \"asctime\": \"2024-07-31 23:26:47,330\", \"message\": \"Starting Tornado Server on port: 8080\", \"module\": \"__main__\"}\n   {\"levelname\": \"INFO\", \"asctime\": \"2024-07-31 23:26:51,177\", \"message\": \"Creating Instance of Pipeline detection/yolov5\", \"module\": \"pipeline_manager\"}\n   {\"levelname\": \"INFO\", \"asctime\": \"2024-07-31 23:26:51,180\", \"message\": \"Gstreamer RTSP Server Started on port: 8555\", \"module\": \"gstreamer_rtsp_server\"}\n   {\"levelname\": \"ERROR\", \"asctime\": \"2024-07-31 23:26:51,200\", \"message\": \"Error on Pipeline 5d5b3b0a4f9411efb60d0242ac120007: gst-resource-error-quark: Could not open resource for reading. (5): ../gst/rtsp/gstrtspsrc.c(6427): gst_rtspsrc_setup_auth (): /GstPipeline:pipeline3/GstURISourceBin:source/GstRTSPSrc:rtspsrc0:\\nNo supported authentication protocol was found\", \"module\": \"gstreamer_pipeline\"}\n</code></pre>"},{"location":"use-cases/automated-self-checkout/catalog/Get-Started-Guide.html#known-issues","title":"Known Issues","text":"<p>For the list of known issues, see known issues.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Overview.html","title":"Automated Self-Checkout Retail Reference Implementation","text":"<p>Use pre-configured optimized computer vision pipelines to build and deploy a self-checkout use case using Intel\u00ae hardware, software, and other open source software.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Overview.html#summary","title":"Summary","text":"<p>The Automated Self-Checkout Reference Implementation provides essential components to build and deploy a self-checkout solution using Intel\u00ae hardware, software, and open source software. It includes the basic services to get you started running optimized Intel\u00ae Deep Learning Streamer (Intel\u00ae DLStreamer)-based computer vision pipelines. These services are modular, allowing for customization or replacement with your solutions to address specific needs.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Overview.html#features-and-benefits","title":"Features and Benefits","text":"<p>With this reference implementation, the self-checkout stations can:</p> <ul> <li>Recognize the non-barcoded items more quickly.</li> <li>Recognize the product SKU and items placed in transparent bags without requiring manual input.</li> <li>Reduce the steps in identifying products when there is no match by suggesting the top five closest choices. </li> </ul> <p>The pre-configured, optimized computer vision pipelines also accelerate the time to market. Inference results are published to Message Queuing Telemetry Transport (MQTT), allowing easy integration with other applications. The implementation includes examples of using different devices such as CPUs, integrated GPUs, and discrete GPUs.</p>"},{"location":"use-cases/automated-self-checkout/catalog/Overview.html#how-it-works","title":"How It Works","text":"<p>In this reference implementation, the video streams from various cameras are cropped and resized to enable the inference engine to run the associated models. The object detection and product classification features identify the SKUs during checkout. The barcode detection, text detection, and recognition features further verify and increase the accuracy of the detected SKUs. The inference details are then aggregated and pushed to  MQTT to process the combined results further.</p> <p>As Figure 1 shows, Docker Compose is used to deploy the reference implementation on different system setups easily. At the same time, MQTT Broker publishes the inference data that external applications or systems can use. Unique MQTT topics are created for each pipeline for a more refined approach to organizing inference outputs.</p> <p></p> <p>Figure 1: Automated Self-Checkout Architectural Diagram</p> <p>Each automated self-checkout pipeline has a pre-configured setup optimized for running on Intel hardware. The following are the available pipelines: </p> <ul> <li><code>yolov5</code>: yolov5 object detection only.</li> <li><code>yolov5_effnet</code>: yolov5 object detection and <code>efficientnet_b0</code> classification.</li> <li><code>yolov5_full</code>: yolov5 object detection, <code>efficientnet_b0</code> classification, text detection, text recognition, and barcode detection.</li> </ul> <p>Figure 2 shows a pipeline in which the video data is ingested and pre-processed before each inferencing step. The data is then analyzed using two models, <code>YOLOv5</code> and <code>EfficientNet</code>, and post-processed to generate metadata and display bounding boxes for each frame. This pipeline is an example of the models and processing workflows supported in this reference implementation.</p> <p></p> <p>Figure 2: Example of a Pipeline Flow</p> <p>The number of streams and pipelines that can be used are system-dependent. For more details, see the latest performance data. </p> <p>The following are the components in the reference implementation.</p> <ul> <li>Edge Video Analytics Microservice (EVAM) is a Python-based, interoperable containerized microservice for the easy development and deployment of video analytics pipelines. It is built on GStreamer and Intel\u00ae DL Streamer, which provide video ingestion and deep learning inferencing functionalities, respectively.</li> <li>Multimodal Data Visualization Microservice enables the visualization of video streams and time-series data.</li> </ul>"},{"location":"use-cases/automated-self-checkout/catalog/Overview.html#learn-more","title":"Learn More","text":"<ul> <li>Get started with the Automated Self-Checkout Retail Reference Implementation using the Get Started Guide.</li> <li>Know more about GStreamer and Intel\u00ae Deep Learning Streamer (DL Streamer).</li> </ul>"},{"location":"use-cases/capi-yolov8-ensemble/capi-yolov8-ensemble.html","title":"Intel\u00ae C-API YOLOV8 Ensemble Object Detection Reference Package","text":""},{"location":"use-cases/capi-yolov8-ensemble/capi-yolov8-ensemble.html#overview","title":"Overview","text":"<p>YOLOv8 is one of the popular YOLO object detection models. To show case the object detection of using YOLOv8, the efficientnet classification model will also be used to help validate the performance and accuracy of the C-API architecture.</p> <p>The YOLOv8 + efficientnet design will follow a similar custom pipeline as the previously implemented YOLOv5 + efficientnet profile. The same gstreamer decoding will be used for the input stream. C-API will send the frames to the OpenVINO Model Server(OVMS) processing through the custom pipeline defined in the config.json. OVMS will output the object bounding boxes along with the object classification. The profile will also output the processing latency in Frames Per Second (FPS).</p> <p></p>"},{"location":"use-cases/capi-yolov8-ensemble/capi-yolov8-ensemble.html#applicable-repos","title":"Applicable Repos","text":"<p>retail-use-cases-gst-capi-yolov8</p>"},{"location":"use-cases/capi-yolov8-ensemble/capi-yolov8-ensemble.html#next-steps","title":"Next Steps","text":"<p>To begin using the C-API YOLOv8 ensemble Helm/Kubernetes solution you can follow the Getting Started Guide. </p>"},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html","title":"Getting Started for K8s C-API YOLOV8","text":""},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#instructions-for-running-k8s-c-api-yolov8-using-minikube","title":"Instructions for Running K8s C-API YOLOv8 using minikube:","text":""},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#presiquistes","title":"Presiquistes:","text":"<ul> <li>Ubuntu 22.04 +</li> <li>minikube</li> <li>kubectl</li> <li>kompose</li> </ul>"},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#build-c-api-yolov8-container-image","title":"Build C-API YOLOv8 Container Image","text":"<p>change directory to <code>use-cases/gst_capi/helm</code> while you are at the retail-use-cases project base directory:</p> <pre><code>```bash\ncd ./use-cases/gst_capi/helm\n```\n</code></pre> <p>and then build the container image for minikube to run:</p> <pre><code>```bash\nmake minikube_build_capi_yolov8_ensemble\n```\n</code></pre> <p>and you should see all of the dependencies built successfully.</p>"},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#run-c-api-yolov8-in-minikube","title":"Run C-API YOLOv8 in minikube","text":"<p>Run the following command while you are still on the directory <code>use-cases/gst_capi/helm</code>:</p> <pre><code>```bash\nmake run_capi_yolov8_ensemble\n```\n</code></pre> <p>and you should see all K8s pods running up.</p>"},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#verify-pods-running","title":"Verify Pods Running","text":"<pre><code>```bash\nkubectl get pod\n```\nResult:\n```console\nNAME                                  READY   STATUS    RESTARTS       AGE\ncamera-simulator-8cffdc4ff-nbcd2      1/1     Running   0              84s\ncamera-simulator0-65779f499-fkk7h     1/1     Running   2 (72s ago)    84s\ncamera-simulator1-8684b659cc-8b4lg    1/1     Running   2 (72s ago)    84s\ncapiyolov8ensemble-57b9ff7d6f-w5hj4   1/1     Running   0              83s\nintel-gpu-plugin-kzxlh                1/1     Running   44 (66m ago)   2d19h\nmqtt-broker-9b597cd94-vxprd           1/1     Running   0              83s\n```\n</code></pre>"},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#verify-results","title":"Verify Results","text":"<pre><code>After starting C-API YOLOv8 ensemble k8s deployment, you will begin to see the FPS results being published into MQTT-broker serice as it can be seen in the log file via running the command:\n\n```bash\nmake minikube_pod_log\n```\n\n```console\n...\ncid: 20241018174229464559017\nPIPELINE_PROFILE: capi_yolov8_ensemble  DEVICE: CPU\nDC: 0 INPUTSRC: rtsp://camera-simulator:8554/camera_1 USE_VPL: 0 RENDER_MODE: 0 RENDER_PORTRAIT_MODE: 0\nCODEC_TYPE: 1 WINDOW_WIDTH: 1280 WINDOW_HEIGHT: 720 DETECTION_THRESHOLD: 0.5\nRESULT_USE_MQTT=1 MQTT_BROKER=mqtt-broker MQTT_PORT=1883\npublish pipeline results using MQTT: mqtt-broker\n_videoStreamPipeline: rtsp://camera-simulator:8554/camera_1\n_use_onevpl: 0\n_render: 0\n_renderPortrait: 0\nvideoType: 1\n_window_width: 1280\n_window_height: 720\nuse mqtt: 1\nmqttBroker: mqtt-broker\nmqtt port =  1883\n...\nlibva info: VA-API version 1.22.0\nlibva info: Trying to open /usr/lib/x86_64-linux-gnu/dri/iHD_drv_video.so\nlibva info: Found init function __vaDriverInit_1_14\nlibva info: va_openDriver() returns 0\n--------------------------------------------------------------\nOpening Media Pipeline: rtspsrc location=rtsp://camera-simulator:8554/camera_1 ! rtph264depay ! h264parse ! vah264dec ! video/x-raw(memory:VAMemory),format=NV12  ! vapostproc !  video/x-raw, width=416, height=416  ! videoconvert ! video/x-raw,format=RGB ! queue ! appsink drop=1 sync=0\n--------------------------------------------------------------\novmsCofigJsonFilePath: /app/gst-ovms/pipelines/yolov8_ensemble/config-yolov8.json\n...\nStarting thread: 131360809276992\n2 object(s) detected at 2024-10-18.17:42:53\nAvg. Pipeline Throughput FPS: 30.000000\nAvg. Pipeline Latency (ms): 58\nMax. Pipeline Latency (ms): 72\nMin. Pipeline Latency (ms): 36\nConnected to MQTT broker: tcp://mqtt-broker:1883\npublishing messages to MQTT broker: tcp://mqtt-broker:1883\ntopic: capiyolov8ensemble/FPS messages: 30.000000\nwaiting for up to 10 seconds for publishing...\ndelivered token: 1 status code = 0\n2 object(s) detected at 2024-10-18.17:42:55\nAvg. Pipeline Throughput FPS: 20.000000\nAvg. Pipeline Latency (ms): 44\nMax. Pipeline Latency (ms): 55\nMin. Pipeline Latency (ms): 39\npublishing messages to MQTT broker: tcp://mqtt-broker:1883\ntopic: capiyolov8ensemble/FPS messages: 20.000000\nwaiting for up to 10 seconds for publishing...\ndelivered token: 2 status code = 0\n...\n```\n</code></pre>"},{"location":"use-cases/capi-yolov8-ensemble/getting_started.html#shutdown-running-containers","title":"Shutdown Running Containers","text":"<pre><code>```bash\nmake down_capi_yolov8_ensemble\n```\n</code></pre>"},{"location":"use-cases/loss-prevention/advanced.html","title":"Advanced Settings","text":"<p>To further customize a loss prevention pipeline, let's add more variables to the execution:</p> <p>Example</p> <pre><code>make PIPELINE_SCRIPT=yolov8s_roi.sh RESULTS_DIR=\"../render_results\"  run-render-mode\n</code></pre> <p>The above command will execute a DLStreamer pipeline using YOLOv8s model for object detection on a region of interest (ROI) with object tracking mechanism.</p>"},{"location":"use-cases/loss-prevention/advanced.html#modify-roi-coordinates","title":"Modify ROI coordinates","text":"<p>To modify the ROI coordinates, locate the file <code>roi.json</code> under src/pipelines/roi.json. Since the \"objects\" attribute is an array, it is possible to add multiple ROIs.</p> <pre><code>[\n    {\n        \"objects\": [\n            {\n                \"detection\": {\n                    \"label\": \"ROI1\"\n                },\n                \"x\": 0,\n                \"y\": 0,\n                \"w\": 620,\n                \"h\": 1080\n            }           \n        ]\n    }\n]\n</code></pre>"},{"location":"use-cases/loss-prevention/advanced.html#class-filtering-for-yolov8-pipeline","title":"Class Filtering for YOLOv8 Pipeline","text":"<p>To detect specific classes using YOLOv8, edit the file <code>src/pipelines/yolov8s_roi.sh</code> and update the variable <code>CLASS_IDS=\"0\"</code> to include the desired class IDs. For example, the default value is set to <code>\"0\"</code>, which corresponds to detecting only the \"person\" class. You can specify multiple class IDs using a comma-separated format like <code>\"0,3,5,4\"</code>, or leave the value empty (<code>\"\"</code>) to detect all classes.</p> <p>To find all supported classes by YOLOv8, you can find them in this file <code>src/extensions/object_filter.py</code>.</p> <pre><code>CLASS_IDS=\"0,2\"\n</code></pre>"},{"location":"use-cases/loss-prevention/advanced.html#mqtt-inference-export-and-roi-detection","title":"MQTT Inference Export and ROI Detection","text":"<p>This application enables monitoring object entry and exit within a defined Region of Interest (ROI), allowing real-time event tracking and external message handling. The <code>yolov8s_roi.json</code> pipeline exports the inference data through MQTT using mosquitto broker defined in the <code>docker-compose.yml</code> file. </p> <p>To change the default MQTT URL, edit the file <code>src/pipelines/yolov8s_roi.sh</code> and update the variable <code>MQTT_HOST=\"127.0.0.1:1883\"</code>.</p> <p>We have developed a business logic application in <code>src/app/loss_prevention.py</code> that tracks objects entering and exiting a defined ROI, generating corresponding events.</p> <p>To configure the app to connect to external MQTT broker, modify the <code>src/docker-compose.yml</code> and change the following env variables:</p> Variable Default Description <code>MQTT_URL</code> <code>127.0.0.1</code> MQTT Broker URL <code>MQTT_PORT</code> <code>1883</code> MQTT Broker Port <code>MQTT_TOPIC</code> <code>event/detection</code> Topic for publishing inference data <code>ROI_NAME</code> <code>BASKET</code> The name of the ROI used to filter objects <p>The following diagram illustrates the containers running:  </p> <p></p>"},{"location":"use-cases/loss-prevention/advanced.html#age-classification-pipeline-usage","title":"Age Classification Pipeline Usage","text":"<p>To run an age classification pipeline, let's change some variables to the execution:</p> <p>Example</p> <pre><code>make PIPELINE_SCRIPT=age_recognition.sh RESULTS_DIR=\"../render_results\" run-render-mode\n</code></pre> <p>The above command will execute a DLStreamer pipeline using a facial detection model for object detection, then running an age/gender classification model on the results of the facial detection model to output the gender and age of the faces in the input frame.</p> <p>For enviroments variables, follow the same tutorial as the automated self checkout HERE</p>"},{"location":"use-cases/loss-prevention/getting_started.html","title":"Getting Started","text":""},{"location":"use-cases/loss-prevention/getting_started.html#step-by-step-instructions","title":"Step by step instructions:","text":"<ol> <li> <p>Download the models using download_models/downloadModels.sh</p> <pre><code>make download-models\n</code></pre> </li> <li> <p>Update github submodules</p> <pre><code>make update-submodules\n</code></pre> </li> <li> <p>Download sample videos used by the performance tools</p> <pre><code>make download-sample-videos\n</code></pre> </li> <li> <p>Build the demo Docker image</p> <pre><code>make build\n</code></pre> </li> <li> <p>Start Loss prevention using the Docker Compose file. The Docker Compose also includes an RTSP camera simulator that will infinitely loop through the sample videos downloaded in step 3.</p> <pre><code>RTSP=1 make run-render-mode\n</code></pre> </li> <li> <p>Open Grafana:</p> </li> </ol> <p>\ud83d\udd17 Grafana Dashboard</p> <p></p> <ol> <li> <p>Verify Docker containers</p> <p><pre><code>docker ps --format 'table{{.Names}}\\t{{.Status}}\\t{{.Image}}'\n</code></pre> Result: <pre><code>NAMES                 STATUS          IMAGE\ncamera-simulator0    Up 17 seconds   jrottenberg/ffmpeg:4.1-alpine\nsrc-OvmsClientGst-1  Up 17 seconds   dlstreamer:dev\ncamera-simulator     Up 17 seconds   aler9/rtsp-simple-server\n</code></pre></p> </li> <li> <p>Verify Results</p> <p>After starting Automated Self Checkout you will begin to see result files being written into the results/ directory. Here are example outputs from the 3 log files.</p> <p>gst-launch__gst.log <pre><code>/GstPipeline:pipeline0/GstGvaWatermark:gvawatermark0/GstCapsFilter:capsfilter1: caps = video/x-raw(memory:VASurface), format=(string)RGBA\n/GstPipeline:pipeline0/GstFPSDisplaySink:fpsdisplaysink0/GstXImageSink:ximagesink0: sync = true\nGot context from element 'vaapipostproc1': gst.vaapi.Display=context, gst.vaapi.Display=(GstVaapiDisplay)\"\\(GstVaapiDisplayGLX\\)\\ vaapidisplayglx0\", gst.vaapi.Display.GObject=(GstObject)\"\\(GstVaapiDisplayGLX\\)\\ vaapidisplayglx0\";\nProgress: (open) Opening Stream\nPipeline is PREROLLED ...\nPrerolled, waiting for progress to finish...\nProgress: (connect) Connecting to rtsp://localhost:8554/camera_0\nProgress: (open) Retrieving server options\nProgress: (open) Retrieving media info\nProgress: (request) SETUP stream 0\n</code></pre> <p>pipeline_gst.log <pre><code>14.58\n14.58\n15.47\n15.47\n15.10\n15.10\n14.60\n14.60\n14.88\n14.88\n</code></pre> <p>r_gst.jsonl <pre><code>{\n    \"objects\": [\n        {\n            \"detection\": {\n                \"bounding_box\": {\n                    \"x_max\": 0.7873924346958825,\n                    \"x_min\": 0.6701603093745723,\n                    \"y_max\": 0.7915918938548927,\n                    \"y_min\": 0.14599881349270305\n                },\n                \"confidence\": 0.8677337765693665,\n                \"label\": \"bottle\",\n                \"label_id\": 39\n            },\n            \"h\": 697,\n            \"region_id\": 610,\n            \"roi_type\": \"bottle\",\n            \"w\": 225,\n            \"x\": 1287,\n            \"y\": 158\n        },\n        {\n            \"detection\": {\n                \"bounding_box\": {\n                    \"x_max\": 0.3221945836811382,\n                    \"x_min\": 0.19950163649114616,\n                    \"y_max\": 0.7924592239981934,\n                    \"y_min\": 0.1336837231479251\n                },\n                \"confidence\": 0.8625879287719727,\n                \"label\": \"bottle\",\n                \"label_id\": 39\n            },\n            \"h\": 711,\n            \"region_id\": 611,\n            \"roi_type\": \"bottle\",\n            \"w\": 236,\n            \"x\": 383,\n            \"y\": 144\n        },\n        {\n            \"detection\": {\n                \"bounding_box\": {\n                    \"x_max\": 0.5730873789069046,\n                    \"x_min\": 0.42000878963365595,\n                    \"y_max\": 0.9749763191740435,\n                    \"y_min\": 0.12431765065780453\n                },\n                \"confidence\": 0.854443371295929,\n                \"label\": \"bottle\",\n                \"label_id\": 39\n            },\n            \"h\": 919,\n            \"region_id\": 612,\n            \"roi_type\": \"bottle\",\n            \"w\": 294,\n            \"x\": 806,\n            \"y\": 134\n        }\n    ],\n    \"resolution\": {\n        \"height\": 1080,\n        \"width\": 1920\n    },\n    \"timestamp\": 755106652\n}\n</code></pre> <li> <p>Stop the demo using docker compose down <pre><code>make down\n</code></pre></p> </li>"},{"location":"use-cases/loss-prevention/getting_started.html#proceed-to-advanced-settings","title":"Proceed to Advanced Settings","text":""},{"location":"use-cases/loss-prevention/loss-prevention.html","title":"Intel\u00ae Loss Prevention Reference Package","text":""},{"location":"use-cases/loss-prevention/loss-prevention.html#overview","title":"Overview","text":"<p>As computer vision technology becomes more mainstream in industrial and retail settings, using it for loss prevention is becoming increasingly complex. These vision workloads are substantial and require multiple stages of processing. For example, a typical loss prevention pipeline might capture video data, define regions of interest, implement tracking to monitor which products customers interact with, analyze the data using models like YOLOv5 and EfficientNet, and then post-process it to generate metadata that highlights which products are being purchased or potentially stolen. This is just one example of how such models and workflows can be utilized.</p> <p>Implementing loss prevention solutions in retail isn't straightforward. Retailers, independent software vendors (ISVs), and system integrators (SIs) need a solid understanding of both hardware and software, as well as the costs involved in setting up and scaling these systems. Given the data-intensive nature of vision workloads, systems must be carefully designed, built, and deployed with numerous considerations in mind. Effectively combating shrinkage requires the right mix of hardware, software, and optimized configurations.</p> <p>The Intel\u00ae Loss Prevention Reference Package is designed to help with this. It provides the essential components needed to develop and deploy a loss prevention solution using Intel\u00ae hardware, software, and open-source tools. This reference implementation includes a pre-configured pipeline that's optimized for Intel\u00ae hardware, simplifying the setup of an effective computer vision-based loss prevention system for retailers.</p>"},{"location":"use-cases/loss-prevention/loss-prevention.html#next-steps","title":"Next Steps","text":"<p>To begin using the loss prevention solution you can follow the Getting Started Guide. </p>"}]}