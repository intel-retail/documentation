{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Intel Retail Documentation","text":"<p>Welcome to the Intel Retail organization.</p>"},{"location":"index.html#learn-more-about-our-features","title":"Learn more about our features","text":"<p>Architecture</p> <p>Performance Tools</p>"},{"location":"Architecture/pipelines.html","title":"Intel Retail","text":""},{"location":"Architecture/pipelines.html#repositories","title":"Repositories","text":"<p>In release v3.0.0 Intel-retail modules have been organized into logical repositories. By taking advantage of github submodules different modules can be refrenced from other repositories. For example performance tools are being used by retail-use-cases and automated-self-checkout. Rather than duplicating and maintaining performance tools between the two repositories we linked the latest performance tools release as a submodule. </p> <p></p>"},{"location":"Architecture/pipelines.html#frameworks","title":"Frameworks","text":""},{"location":"Architecture/pipelines.html#openvino","title":"OpenVINO","text":"<p>OpenVINO is an open source toolkit provided by Intel to assist with running AI and ML on Intel hardware. The tools include a portable inference engine that is compatible with different Intel hardware platforms. The code can be found on the OpenVINO Github and examples can be ran through the OpenVINO Jupyter Notebooks.</p> <p>OpenVINO provides some pre-trained models for quick development and testing through the OpenVINO Model Zoo. OpenVINO also supports converting models through they Model Conversion Process</p> <p>Details about the latest version can be found in the OpenVINO Release Notes.</p>"},{"location":"Architecture/pipelines.html#dlstreamer-pipeline","title":"DLStreamer Pipeline","text":"<p>Rather than working directly with the OpenVINO APIs our solutions offers more practical ways to interface with OpenVINO. One method is using Intel DLStreamer. This solution provides a no code way based on GStreamer and OpenVINO to deploy, process, and output a pipeline. </p> <p>The diagrams show how we take advantage of Docker, Docker Compose, and environment variable files to pre-package DLStreamer based pipelines for our use cases. Leveraging Environment Variables allows users to modify properties on the fly when different configurations are required.</p> <p></p>"},{"location":"Architecture/pipelines.html#openvino-model-serverovms","title":"OpenVINO Model Server(OVMS)","text":"<p>Another solution is the OpenVINO Model Server(OVMS). OVMS is a model hosting server that hosts inference models through a set of APIs. Unlike DLStreamer this solution requires developers to write code for pre and post processing model inference results. The advantage is the additional control developers have over their inference processing. Another benefit is the distribution of inference workloads between multiple servers either locally or remotely.</p>"},{"location":"Architecture/pipelines.html#openvino-model-serverovms-pipeline-with-grpc-remote-procedure-call","title":"OpenVINO Model Server(OVMS) Pipeline with gRPC (Remote Procedure Call)","text":"<p>There are two methods for running your inference through OVMS. The more flexible method has the client use gRPC (Remote Procedure Call)  to request inference results from OVMS. By providing the proper input type and format the client can push inference comput to OVMS. OVMS can be local or on a remote system as long as the requested model is supported. This provides great flexibility with only minor latency increase. </p> <p>The gRPC interface supports c/c++, python, and golang. A python example is located in our retial-use-cases gRPC python. The diagram show how the Docker Compose will deploy the client and OVMS. </p> <p></p>"},{"location":"Architecture/pipelines.html#openvino-model-serverovms-pipeline-with-c-api","title":"OpenVINO Model Server(OVMS) Pipeline with C API","text":"<p>When performance is more important than flexibility a developer can use the C API to bypass the gRPC interface and reudce latency. This method is currently only supported for c/c++ and required client/OVMS to both be deployed in a single Docker container. and example of a C API pipeline can be found in retail-use-cases gst_capi. Similar to DLStreamer the Docker Compose only launches a single container per pipeline now that the client/OVMS directly connect through the C API.</p> <p></p>"},{"location":"Architecture/pipelines.html#performance","title":"Performance","text":"<p>More details about benchmarking pipelines can be found on the Performance Tools Page.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html","title":"Distributed Architecture","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/distributed-architecture.html#context","title":"Context","text":"<p>To a wider variety of computer vision use cases in the real world a distributed inference architecture is required for deployment and scale. To achieve this, OpenVINO Model Server (OVMS) will be used for server side inferencing as part of the architecture design. The new architecture will lose some inference throughput but gain flexibility and scale.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#proposed-design","title":"Proposed Design","text":"<p>Using OpenVINO Model Server (OVMS) pipeline, workloads can be distributed between different services. For our solution a single system and remote server setup will be supported.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#single-system-setup","title":"Single System Setup","text":"<p>The single system solution will launch both the OVMS client and OVMS server on the same system as Docker containers. The local network can be used for communication between the Docker containers. The profile launcher program will load the profile configs and environment variables form a local data volume. The computer vision models will also be located on a local data volume. The models can be downloaded using the provided scripts or manually by the user.</p> <p></p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#remote-server-setup","title":"Remote Server Setup","text":"<p>The remote serve set will launch the same OVMS client and OVMS server containers but on two different systems. These systems can be on the same network on in remote locations as long as the systems can communicate through the network. This will require additional security or a direct connection from client to server. Similar to the single system the profile launcher will load the profile configs and environment variables from a data volume. In this case the data volume can be a local copy or a remote copy of those files. On the server the computer vision models will be in a data volume. Unlike the profile config and environment files these must be located on the server in a data volume. This is to prevent any unwanted changes to the computer vision model when it is located in a remote location. </p> <p></p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#running-the-pipeline","title":"Running the Pipeline","text":"<p>The profile launching program will start a pre-configured OVMS client and OVMS server. Run Pipeline documentation covers the parameter details and how to configure different input sources.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#consequences","title":"Consequences","text":"<p>Unlike DLStreamer there will be some latency to call OVMS through gRPC. This will results in a slightly lower stream density for systems. We will however support a wider range and combination of models since the inferencing will be abstracted into the OpenVINO Model Server.</p>"},{"location":"Architecture/v2.0.0/distributed-architecture.html#references","title":"References","text":"<p>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html https://github.com/openvinotoolkit/model_server</p>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html","title":"Multiple OpenVINO Model Server Config JSON","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#context","title":"Context","text":"<p>Currently, we use same config.json for all instances of OpenVINO Model Server(OVMS) pipelines, which leads to some issue regarding the device mounting for OVMS server: see issue intel-retail/automated-self-checkout#322. So we need a way to have multiple or unique config json file per OVMS instance.</p>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#proposed-design","title":"Proposed Design","text":"<p>Move the current device update logic from <code>run.sh</code> with the config.json file into profile-launcher in Golang. When profile-launcher about to launch a new instance of OVMS server, it then produces a unique config json file name for that instance of OVMS server.</p> <p>For example, we can use the Docker container name of that OVMS server like ovms_server0, or ovms_server1,...etc to be appended into the config json as part of the file name (e.g. config_ovms_server0.json).</p> <p>One example golang code for updating json file target_device and producing a new config.json is shown below: <pre><code>// ----------------------------------------------------------------------------------\n// Copyright 2023 Intel Corp.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n//\n// ----------------------------------------------------------------------------------\n\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"reflect\"\n)\n\ntype OvmsConfig struct {\n    ModelList []ModelConfig `json:\"model_config_list\"`\n}\n\ntype ModelConfig struct {\n    Config map[string]interface{} `json:\"config\"`\n}\n\nfunc main() {\n    updateConfig(\"CPU\")\n}\n\nfunc updateConfig(device string) {\n    contents, err := os.ReadFile(\"config_template.json\")\n    if err != nil {\n        err = fmt.Errorf(\"Cannot read json config %v\", err)\n    }\n\n    var data OvmsConfig\n    err = json.Unmarshal(contents, &amp;data)\n    if err != nil {\n        log.Fatalf(\"failed to unmarshal configuration file configuration.yaml: %v\", err)\n    }\n\n    fmt.Println(reflect.TypeOf(data.ModelList))\n\n    for _, model := range data.ModelList {\n        // fmt.Println(model)\n        model.Config[\"target_device\"] = device\n        fmt.Println(model.Config[\"target_device\"])\n        fmt.Println(\"!!!!!!!!!!!!\")\n        fmt.Println(model.Config)\n    }\n\n    // convert to struct\n    updateConfig, err := json.Marshal(data)\n    if err != nil {\n        log.Fatalf(\"could not marshal config to JSON: %v\", err)\n    }\n    _ = os.WriteFile(\"config_ovms_server0.json\", updateConfig, 0644)\n}\n</code></pre></p> <p>This step is done before the profile-launcher calling the <code>start_ovms_server.sh</code>script.</p> <p>In the profile-launcher we also set the correct  environment variable values for the <code>start_ovms_server.sh</code>script to use.  For example, <code>OVMS_MODEL_CONFIG_JSON</code> to be the unique config json file name that was produced from the above example.</p> <p>For clean-up, we can do deletion of the config json files when <code>make clean-all</code> is called or <code>make clean-ovms-server</code> is called.</p>"},{"location":"Architecture/v2.0.0/multiple-ovms-json-config.html#references","title":"References","text":"<ul> <li>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html</li> <li>https://github.com/openvinotoolkit/model_server</li> <li>see issue Classification profile crashed when run the 2nd instance switch from CPU to GPU.0 automated-self-checkout#322</li> </ul>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html","title":"Performance Benchmarking","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/performance_benchmarking.html#context","title":"Context","text":"<p>To assist customers we will provide a set of performance Docker containers to measure the performance of their pipelines. The performance Docker containers will need to be supported on most modern Intel hardware. The output will also need to be formatted and presented to customers as a hardware recommendation.</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#proposed-design","title":"Proposed Design","text":""},{"location":"Architecture/v2.0.0/performance_benchmarking.html#benchmark-script","title":"Benchmark Script","text":"<p>The benchmark script is designed to help determine the performance needs for a specific pipeline profile. The script will run a designated pipeline profile and can either replicate that pipeline profile a specific number of times or continue to replicate until a performance target is reached.</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#performance-tools","title":"Performance tools","text":"<p>sysstat: System CPU utilization free: System memory usage iotop: System Disk read and write data igt-gpu-tools: Integrated GPU utilization Intel XPU Manage: Discrete GPU utilization Intel Performance Counter Monitor: System power usage</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#input-source-types","title":"Input Source Types","text":"<p>For performance inputs we support RTSP video streams, USB camera, Intel\u00ae RealSense\u2122 Camera, and video files. For longer benchmarking runs its' recommended to use a video loop with an RTSP stream for inference result consistency. As an option an RTSP Camera Simulator is provided with the performance script.</p> <p>Input Source Types</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#specified-number-of-pipelines","title":"Specified Number of Pipelines","text":"<p>If you are looking to test a specific number of pipelines on different hardware SKUs the <code>--pipelines</code> parameter can be used. This parameter will start the specified number of pipelines </p> <p>Specified Number of Pipelines</p> <p></p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#consolidated-results","title":"Consolidated Results","text":"<p>To make reading results easier, a consolidation script has been provided. This script will work with a single or multiple runs of the specified number of pipelines. Details about this process are found in Benchmark Specified Number of Pipelines</p> <pre><code>make consolidate ROOT_DIRECTORY=&lt;output dir&gt;\n</code></pre>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#stream-density","title":"Stream Density","text":"<p>The stream density parameter can be used to find the maximum number of pipelines at a target frames per second (FPS) on a specific hardware SKU. By setting the <code>--stream_density</code> parameter to the desired FPS the script will continue to create pipelines until the average pipelines FPS falls below the desired FPS. The script will provide a detailed log to show each pipeline FPS during the test run. This option provides a method for testing the top performance when introducing a new pipeline or hardware SKU.</p> <p>Stream Density</p> <p></p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#consequences","title":"Consequences","text":"<p>Having a generic and scalable set of performance Docker containers will allow customers to test a wide range of pipelines and hardware setups without extensive configuration of their systems. The flexibility will bring faster time to market and better hardware decision making by customers.</p>"},{"location":"Architecture/v2.0.0/performance_benchmarking.html#references","title":"References","text":"<p>Pipeline Benchmarking</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html","title":"Distributed Architecture","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/profile-launcher.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/profile-launcher.html#context","title":"Context","text":"<p>Depending on the underlying pipeline architecture you may only require one Docker container or you may require many Docker containers. Specifically OVMS has two methods for running: gRPC which uses remote inference calls from a client to server and Capi which does the inferencing locally. Additionally other methods such as GStreamer are run in a single container. The profiles should be able to accommodate both use cases.</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#proposed-design","title":"Proposed Design","text":"<p>Update the profile to handle an array of configurations. This will allow the user to mix multiple Docker container configurations into a single profile.</p> <p>Each container configuration will contain the following information: - Docker image: The profile launcher will use as the target image - Environment file: Loaded into the container - Entrypoint script: Launch the desired start process - Input arguments: container or entrypoint script - Docker Volumes: Mounted to the container - Docker Networks: Connected to the container</p> <p></p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#single-container-profile","title":"Single Container Profile","text":"<p>A single container profile will run a single Docker image using a single entrypoint script. This use case will be for pipelines that are self contained in a single container. Although the container can interact with other containers on the system the performance tools will only measure the performance of the single running container.</p> <p></p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#multiple-container-profile","title":"Multiple Container Profile","text":"<p>A multiple container profile will run the array of containers defined in the profile config. Each container can have it's own entrypoint script even if they utilize the same base Docker image. The common profile will be the OpenVINO Model Server and client. In this case a OVMS container will contain the inference models defined in the config.json from the profile. Once the OVMS container is started the client will be launched and connect to the OVMS container. This will result in the inference workload being executed in a difference service which can be on the local system or in a remote location. </p> <p></p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#consequences","title":"Consequences","text":"<p>All profiles will need to be updated to use this new array structure. As a benefit common containers such as the OpenVINO Model Server can be shared between profiles.</p>"},{"location":"Architecture/v2.0.0/profile-launcher.html#references","title":"References","text":"<p>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html https://github.com/openvinotoolkit/model_server</p>"},{"location":"Architecture/v2.0.0/target-device.html","title":"Distributed Architecture","text":"<ul> <li>Status</li> <li>Decision</li> <li>Context</li> <li>Proposed Design</li> <li>Consequences</li> <li>References</li> </ul>"},{"location":"Architecture/v2.0.0/target-device.html#decision","title":"Decision","text":""},{"location":"Architecture/v2.0.0/target-device.html#context","title":"Context","text":"<p>The platform parameter is inconsistent with the target device being used in the pipeline. To be consistent with OVMS we want to use the target_device parameter in the script to match the target_device setting in the OVMS config file.</p>"},{"location":"Architecture/v2.0.0/target-device.html#proposed-design","title":"Proposed Design","text":"<p>Update the platform parameter to match the target_device standard used by OpenVINO Model Server. This will provide clarity to the device being used for the inferencing portion of the pipeline. The following are the acceptance criteria for the change.</p> <ul> <li>Replace platform parameter with target_device using CPU as the default device.</li> <li>Update the docker_run script to make it run with minimal changes to the profiles.</li> <li>Confirm that the benchmark script works with the target_device parameter update.</li> <li>Update unit tests</li> <li>Update documentation</li> <li>Convert $DEVICE to $TARGET_DEVICE for internal environment variables.</li> <li>Add option to use existing config file and not override all target_devices to support models with different target_device values.</li> </ul>"},{"location":"Architecture/v2.0.0/target-device.html#target-device-list","title":"Target Device list","text":"Device Parameter Description Links CPU CPU Use CPU only OVMS Parameters GPU GPU Use default GPU OVMS Parameters Specified GPU GPU.x Use a specific GPU. ex. GPU.0 = integrated GPU, GPU.1 = discrete Arc GPU OVMS Parameters Mixed Contifuration MULTI:x,y Use a combination of devices for inferencing ex. MULTI:CPU,GPU.1 will use the CPU and discrete Arc GPU for inferencing OVMS Parameters Automatic Device Selection AUTO Allow OpenVINO to automatically select the optimal device for inferencing Possibly depricated? Automatic Device Selection AUTO Allow OpenVINO to automatically select the optimal device for inferencing Possibly depricated? Heterogeneous Execution HETERO Allows OpenVINO to execute inference on multiple devices Heterogeneous Execution Heterogeneous Execution Priority HETERO:x,y Allows OpenVINO to execute inference on multiple devices and set the priority of device. ex. HETERO:CPU,GPU.1 will prioritize CPU and discrete Arc GPU for inferencing Heterogeneous Execution"},{"location":"Architecture/v2.0.0/target-device.html#applicable-repos","title":"Applicable Repos","text":"<p>automated-self-checkout</p>"},{"location":"Architecture/v2.0.0/target-device.html#consequences","title":"Consequences","text":"<p>Removing the platform parameter will break any existing test and benchmark scripts. The change will clarify which device you are targeting for the inference.</p>"},{"location":"Architecture/v2.0.0/target-device.html#references","title":"References","text":"<p>https://docs.openvino.ai/2023.0/ovms_what_is_openvino_model_server.html https://github.com/openvinotoolkit/model_server</p>"},{"location":"performance-tools/benchmark.html","title":"Computer Vision Pipeline Benchmarking","text":"<p>The provided Python-based script works with Docker Compose to get pipeline performance  metrics like video processing in frames-per-second (FPS), memory usage, power consumption, and so on.</p>"},{"location":"performance-tools/benchmark.html#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python environment v3.12.2</p> <p>Note</p> <p>This could be accomplished using Miniconda and creating a Python 3.12.2 env</p> </li> <li> <p>Python packages listed in performance-tools/benchmark-scripts/requirements.txt</p> <p>Note</p> <p>Use <code>pip install -r requirements.txt</code></p> </li> <li> <p>Docker</p> </li> <li>Docker Compose</li> <li>Make</li> <li>Git</li> <li> <p>Code from Retail Use Cases Repo and its submodule Performance Tools Repo</p> <p>Note</p> <p>To install the submodule, run <code>make update-submodules</code> from the root of the retail-use-cases repo.</p> </li> </ul>"},{"location":"performance-tools/benchmark.html#benchmark-a-cv-pipeline","title":"Benchmark a CV Pipeline","text":"<ol> <li>Build the benchmark container and change into the benchmark-scripts directory.</li> </ol> <p><pre><code>make build-benchmark-docker\ncd benchmark-scripts\n</code></pre> 2. Choose a CV pipeline from the Retail Use Cases Repo and note the file paths to the docker compose files. 3. Run the benchmarking script using the docker compose file(s) as inputs to the script (sample command shown below).</p> <pre><code>```bash\npython benchmark.py --compose_file ../../use-cases/gst_capi/add_camera-simulator.yml --compose_file ../../use-cases/gst_capi/add_gst_capi_yolov5_ensemble.yml\n```\n</code></pre> <p>Specific number of pipelines with single container </p> <p>Specific number of pipelines with OVMS and Client </p>"},{"location":"performance-tools/benchmark.html#benchmark-stream-density-for-cv-pipelines","title":"Benchmark Stream Density for CV Pipelines","text":"<p>Benchmarking a pipeline can also discover the maximum number of workloads or streams that can be run in parallel for a given target FPS. This information is useful to determine the hardware required to achieve the desired performance for CV pipelines.</p> <p>To run the stream density functionality use <code>--target_fps</code> and/or <code>--density_increment</code> as inputs to the <code>benchmark.py</code> script:</p> <pre><code> python benchmark.py  --retail_use_case_root ../../retail-use-cases --target_fps 14.95 --density_increment 1 --init_duration 40   --compose_file ../../retail-use-cases/use-cases/grpc_python/docker-compose_grpc_python.yml\n</code></pre> <p>where the parameters: - <code>target_fps</code> is the given target frames per second (fps) to achive for maximum number of pipelines - <code>density_increment</code> is to configure the benchmark logic to increase the number of pipelines each time while trying to find out the maximum number of pipelines before reaching the given target fps. - <code>init_duration</code> is the initial duration period in second before pipeline performance metrics are taken</p> <pre><code>!!! Note\n    It is recommended to set --target_fps to a value lesser than your target FPS to account for real world variances in hardware readings.\n</code></pre> <p>Stream density with single container </p> <p>Stream density with OVMS and Client </p>"},{"location":"performance-tools/benchmark.html#modifying-additional-benchmarking-variables","title":"Modifying Additional Benchmarking Variables","text":""},{"location":"performance-tools/benchmark.html#change-power-profile","title":"Change Power Profile","text":"<ul> <li>For Ubuntu, follow this documentation to change the power profile.</li> <li>For Windows, follow this documentation to change the power mode.</li> </ul>"},{"location":"performance-tools/benchmark.html#developer-resources","title":"Developer Resources","text":""},{"location":"performance-tools/benchmark.html#python-testing","title":"Python Testing","text":"<p>To run the unit tests for the performance tools:</p> <pre><code>cd benchmark-scripts\nmake python-test\n</code></pre> <p>To run the unit tests and determine the coverage:</p> <pre><code>cd benchmark-scripts\nmake python-coverage\n</code></pre>"}]}